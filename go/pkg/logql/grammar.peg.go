package logql

// Code generated by peg /Users/antoine/code/src/github.com/humanlogio/api/go/pkg/logql/grammar.peg DO NOT EDIT.

import (
	"fmt"
	"github.com/humanlogio/api/go/types/v1"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleQueryContext
	ruleQueryContextItem
	ruleQueryFrom
	ruleQueryTo
	ruleQueryMachineContext
	ruleQuerySessionContext
	ruleStatements
	ruleStatement
	ruleFilterOperator
	ruleSummarizeOperator
	ruleByOperator
	ruleByOperatorArg
	ruleProjectOperator
	ruleProjectArg
	ruleExpr
	ruleExpr1
	ruleExpr2
	ruleExpr3
	ruleExpr4
	ruleExpr5
	ruleLiteral
	ruleFuncCall
	ruleFuncName
	ruleFuncArgs
	ruleFuncArg
	ruleIdentifier
	ruleString
	ruleSelectorId
	ruleF64
	ruleI64
	ruleBool
	ruleReservedKeyword
	ruleArray
	ruleArrayItem
	ruleObject
	ruleObjectItem
	ruleObjectKey
	ruleDuration
	ruleTimestamp
	ruleStringChar
	ruleExponent
	ruleDigits
	ruleRFC3339Nano
	ruleRFC3339NanoDate
	ruleRFC3339NanoTime
	ruleRFC3339NanoTimezone
	ruleNumber
	ruleNOT
	ruleNEG
	ruleNUM_ADD
	ruleNUM_SUB
	ruleNUM_DIV
	ruleNUM_MUL
	ruleLOG_AND
	ruleLOG_OR
	ruleCMP_EQ
	ruleCMP_NOTEQ
	ruleCMP_GT
	ruleCMP_GTE
	ruleCMP_LT
	ruleCMP_LTE
	ruleSET_IN
	ruleSET_NOTIN
	rulePIPE
	ruleDOT
	ruleL_PARENS
	ruleR_PARENS
	ruleL_BRACKET
	ruleR_BRACKET
	ruleL_SQUIGGLY
	ruleR_SQUIGGLY
	ruleCOLON
	ruleCOMMA
	ruleSpace
	ruleMustSpace
	ruleWhitespace
	ruleEOL
	ruleEOF
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	rulePegText
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"QueryContext",
	"QueryContextItem",
	"QueryFrom",
	"QueryTo",
	"QueryMachineContext",
	"QuerySessionContext",
	"Statements",
	"Statement",
	"FilterOperator",
	"SummarizeOperator",
	"ByOperator",
	"ByOperatorArg",
	"ProjectOperator",
	"ProjectArg",
	"Expr",
	"Expr1",
	"Expr2",
	"Expr3",
	"Expr4",
	"Expr5",
	"Literal",
	"FuncCall",
	"FuncName",
	"FuncArgs",
	"FuncArg",
	"Identifier",
	"String",
	"SelectorId",
	"F64",
	"I64",
	"Bool",
	"ReservedKeyword",
	"Array",
	"ArrayItem",
	"Object",
	"ObjectItem",
	"ObjectKey",
	"Duration",
	"Timestamp",
	"StringChar",
	"Exponent",
	"Digits",
	"RFC3339Nano",
	"RFC3339NanoDate",
	"RFC3339NanoTime",
	"RFC3339NanoTimezone",
	"Number",
	"NOT",
	"NEG",
	"NUM_ADD",
	"NUM_SUB",
	"NUM_DIV",
	"NUM_MUL",
	"LOG_AND",
	"LOG_OR",
	"CMP_EQ",
	"CMP_NOTEQ",
	"CMP_GT",
	"CMP_GTE",
	"CMP_LT",
	"CMP_LTE",
	"SET_IN",
	"SET_NOTIN",
	"PIPE",
	"DOT",
	"L_PARENS",
	"R_PARENS",
	"L_BRACKET",
	"R_BRACKET",
	"L_SQUIGGLY",
	"R_SQUIGGLY",
	"COLON",
	"COMMA",
	"Space",
	"MustSpace",
	"Whitespace",
	"EOL",
	"EOF",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"PegText",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type logQL struct {

	// the query being built
	LogQuery *typesv1.LogQuery

	// stack for recursive generic structures
	Exprs []*typesv1.Expr

	// accumulate statements
	Stmts []*typesv1.Statement

	// scratch space for table operators
	FilterOp    *typesv1.FilterOperator
	SummarizeOp *typesv1.SummarizeOperator
	ProjectOp   *typesv1.ProjectOperator

	// scratch space, not needed but `Literal` being a type is convenient
	Literal *typesv1.Val

	// scalars
	String    string
	F64       float64
	I64       int64
	Bool      bool
	Timestamp time.Time
	Duration  time.Duration

	// stack for non-expr recursive structures
	Arrs      [][]*typesv1.Val
	ObjsKVs   [][]*typesv1.KV
	FuncCalls []*typesv1.FuncCall

	// errors seen along the way
	err error

	Buffer string
	buffer []rune
	rules  [152]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *logQL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *logQL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *logQL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *logQL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *logQL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *logQL) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *logQL) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.SetQuery(p.Stmts)
		case ruleAction1:
			p.SetQuery(p.Stmts)
		case ruleAction2:
			p.SetFrom(p.popExpr())
		case ruleAction3:
			p.SetTo(p.popExpr())
		case ruleAction4:
			p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction5:
			p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction6:
			p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction7:
			p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction8:
			p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction9:
			p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction10:
			p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction11:
			p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction12:
			p.addFilterStatement(p.FilterOp)
		case ruleAction13:
			p.addSummarizeStatement(p.SummarizeOp)
		case ruleAction14:
			p.addProjectStatement(p.ProjectOp)
		case ruleAction15:
			p.setFilterOp(p.popExpr())
		case ruleAction16:
			p.startSummarizeOp(p.popFunc())
		case ruleAction17:
			p.addSummarizeByOp(p.popExpr())
		case ruleAction18:
			p.startProjectOp()
		case ruleAction19:
			p.startProjectOpArg(text)
		case ruleAction20:
			p.setProjectOpArgValue(p.popExpr())
		case ruleAction21:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs))
		case ruleAction22:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs))
		case ruleAction23:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs))
		case ruleAction24:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs))
		case ruleAction25:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs))
		case ruleAction26:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs))
		case ruleAction27:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs))
		case ruleAction28:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs))
		case ruleAction29:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs))
		case ruleAction30:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs))
		case ruleAction31:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs))
		case ruleAction32:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs))
		case ruleAction33:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs))
		case ruleAction34:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs))
		case ruleAction35:
			index, x := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprIndexor(x, index))
		case ruleAction36:
			selector, x := text, p.popExpr()
			p.pushExpr(typesv1.ExprSelector(x, selector))
		case ruleAction37:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction38:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg))
		case ruleAction39:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction40:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg))
		case ruleAction41:
			p.pushExpr(typesv1.ExprLiteral(p.Literal))
			p.Literal = nil
		case ruleAction42:
			fn := p.popFunc()
			p.pushExpr(typesv1.ExprFuncCall(fn.Name, fn.Args...))
		case ruleAction43:
			p.Literal = typesv1.ValStr(p.String)
		case ruleAction44:
			p.Literal = typesv1.ValDuration(p.Duration)
		case ruleAction45:
			p.Literal = typesv1.ValTime(p.Timestamp)
		case ruleAction46:
			p.Literal = typesv1.ValF64(p.F64)
		case ruleAction47:
			p.Literal = typesv1.ValI64(p.I64)
		case ruleAction48:
			p.Literal = typesv1.ValBool(p.Bool)
		case ruleAction49:
			p.Literal = typesv1.ValArr(p.popArray()...)
		case ruleAction50:
			p.Literal = typesv1.ValObj(p.popObj()...)
		case ruleAction51:
			p.pushFunc()
		case ruleAction52:
			p.setFuncName(text)
		case ruleAction53:
			p.addFuncArg(p.popExpr())
		case ruleAction54:
			p.pushExpr(typesv1.ExprIdentifier(text))
		case ruleAction55:
			p.String = p.parseString(text)
		case ruleAction56:
			p.F64 = p.parseFloat64(text)
		case ruleAction57:
			p.F64 = p.parseFloat64(text)
		case ruleAction58:
			p.F64 = p.parseFloat64(text)
		case ruleAction59:
			p.I64 = 0
		case ruleAction60:
			p.I64 = p.parseInt64(text)
		case ruleAction61:
			p.Bool = true
		case ruleAction62:
			p.Bool = false
		case ruleAction63:
			p.pushArray()
		case ruleAction64:
			p.addArrItem(p.Literal)
			p.Literal = nil
		case ruleAction65:
			p.pushObj()
		case ruleAction66:
			p.closeObjItem(p.Literal)
			p.Literal = nil
		case ruleAction67:
			p.startObjItem(p.String)
		case ruleAction68:
			p.Duration = p.parseDurationF64(p.F64, text)
		case ruleAction69:
			p.Duration = p.parseDurationI64(p.I64, text)
		case ruleAction70:
			p.Timestamp = p.parseTime(time.RFC3339Nano, text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*logQL) error {
	return func(p *logQL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*logQL) error {
	return func(p *logQL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *logQL) Init(options ...func(*logQL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Space ((Statements Action0) / ((QueryContext MustSpace)? Statements Action1) / QueryContext)? EOF)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpace]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleStatements]() {
							goto l5
						}
						if !_rules[ruleAction0]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						{
							position7, tokenIndex7 := position, tokenIndex
							if !_rules[ruleQueryContext]() {
								goto l7
							}
							if !_rules[ruleMustSpace]() {
								goto l7
							}
							goto l8
						l7:
							position, tokenIndex = position7, tokenIndex7
						}
					l8:
						if !_rules[ruleStatements]() {
							goto l6
						}
						if !_rules[ruleAction1]() {
							goto l6
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleQueryContext]() {
							goto l2
						}
					}
				l4:
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
				if !_rules[ruleEOF]() {
					goto l0
				}
				add(ruleGrammar, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 QueryContext <- <(L_SQUIGGLY Space QueryContextItem+ R_SQUIGGLY)> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l9
				}
				if !_rules[ruleSpace]() {
					goto l9
				}
				if !_rules[ruleQueryContextItem]() {
					goto l9
				}
			l11:
				{
					position12, tokenIndex12 := position, tokenIndex
					if !_rules[ruleQueryContextItem]() {
						goto l12
					}
					goto l11
				l12:
					position, tokenIndex = position12, tokenIndex12
				}
				if !_rules[ruleR_SQUIGGLY]() {
					goto l9
				}
				add(ruleQueryContext, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 QueryContextItem <- <((QueryMachineContext / QuerySessionContext / QueryFrom / QueryTo) Space)> */
		func() bool {
			position13, tokenIndex13 := position, tokenIndex
			{
				position14 := position
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleQueryMachineContext]() {
						goto l16
					}
					goto l15
				l16:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQuerySessionContext]() {
						goto l17
					}
					goto l15
				l17:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQueryFrom]() {
						goto l18
					}
					goto l15
				l18:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQueryTo]() {
						goto l13
					}
				}
			l15:
				if !_rules[ruleSpace]() {
					goto l13
				}
				add(ruleQueryContextItem, position14)
			}
			return true
		l13:
			position, tokenIndex = position13, tokenIndex13
			return false
		},
		/* 3 QueryFrom <- <('f' 'r' 'o' 'm' Space CMP_EQ Space Expr Action2)> */
		func() bool {
			position19, tokenIndex19 := position, tokenIndex
			{
				position20 := position
				if buffer[position] != rune('f') {
					goto l19
				}
				position++
				if buffer[position] != rune('r') {
					goto l19
				}
				position++
				if buffer[position] != rune('o') {
					goto l19
				}
				position++
				if buffer[position] != rune('m') {
					goto l19
				}
				position++
				if !_rules[ruleSpace]() {
					goto l19
				}
				if !_rules[ruleCMP_EQ]() {
					goto l19
				}
				if !_rules[ruleSpace]() {
					goto l19
				}
				if !_rules[ruleExpr]() {
					goto l19
				}
				if !_rules[ruleAction2]() {
					goto l19
				}
				add(ruleQueryFrom, position20)
			}
			return true
		l19:
			position, tokenIndex = position19, tokenIndex19
			return false
		},
		/* 4 QueryTo <- <('t' 'o' Space CMP_EQ Space Expr Action3)> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if buffer[position] != rune('t') {
					goto l21
				}
				position++
				if buffer[position] != rune('o') {
					goto l21
				}
				position++
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleCMP_EQ]() {
					goto l21
				}
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleExpr]() {
					goto l21
				}
				if !_rules[ruleAction3]() {
					goto l21
				}
				add(ruleQueryTo, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 5 QueryMachineContext <- <('m' 'a' 'c' 'h' 'i' 'n' 'e' Space ((CMP_EQ Space Expr Action4) / (CMP_NOTEQ Space Expr Action5) / (SET_IN Space Expr Action6) / (SET_NOTIN Space Expr Action7)))> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if buffer[position] != rune('m') {
					goto l23
				}
				position++
				if buffer[position] != rune('a') {
					goto l23
				}
				position++
				if buffer[position] != rune('c') {
					goto l23
				}
				position++
				if buffer[position] != rune('h') {
					goto l23
				}
				position++
				if buffer[position] != rune('i') {
					goto l23
				}
				position++
				if buffer[position] != rune('n') {
					goto l23
				}
				position++
				if buffer[position] != rune('e') {
					goto l23
				}
				position++
				if !_rules[ruleSpace]() {
					goto l23
				}
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l26
					}
					if !_rules[ruleSpace]() {
						goto l26
					}
					if !_rules[ruleExpr]() {
						goto l26
					}
					if !_rules[ruleAction4]() {
						goto l26
					}
					goto l25
				l26:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleCMP_NOTEQ]() {
						goto l27
					}
					if !_rules[ruleSpace]() {
						goto l27
					}
					if !_rules[ruleExpr]() {
						goto l27
					}
					if !_rules[ruleAction5]() {
						goto l27
					}
					goto l25
				l27:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleSET_IN]() {
						goto l28
					}
					if !_rules[ruleSpace]() {
						goto l28
					}
					if !_rules[ruleExpr]() {
						goto l28
					}
					if !_rules[ruleAction6]() {
						goto l28
					}
					goto l25
				l28:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleSET_NOTIN]() {
						goto l23
					}
					if !_rules[ruleSpace]() {
						goto l23
					}
					if !_rules[ruleExpr]() {
						goto l23
					}
					if !_rules[ruleAction7]() {
						goto l23
					}
				}
			l25:
				add(ruleQueryMachineContext, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 6 QuerySessionContext <- <('s' 'e' 's' 's' 'i' 'o' 'n' Space ((CMP_EQ Space Expr Action8) / (CMP_NOTEQ Space Expr Action9) / (SET_IN Space Expr Action10) / (SET_NOTIN Space Expr Action11)))> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('e') {
					goto l29
				}
				position++
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('i') {
					goto l29
				}
				position++
				if buffer[position] != rune('o') {
					goto l29
				}
				position++
				if buffer[position] != rune('n') {
					goto l29
				}
				position++
				if !_rules[ruleSpace]() {
					goto l29
				}
				{
					position31, tokenIndex31 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l32
					}
					if !_rules[ruleSpace]() {
						goto l32
					}
					if !_rules[ruleExpr]() {
						goto l32
					}
					if !_rules[ruleAction8]() {
						goto l32
					}
					goto l31
				l32:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleCMP_NOTEQ]() {
						goto l33
					}
					if !_rules[ruleSpace]() {
						goto l33
					}
					if !_rules[ruleExpr]() {
						goto l33
					}
					if !_rules[ruleAction9]() {
						goto l33
					}
					goto l31
				l33:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleSET_IN]() {
						goto l34
					}
					if !_rules[ruleSpace]() {
						goto l34
					}
					if !_rules[ruleExpr]() {
						goto l34
					}
					if !_rules[ruleAction10]() {
						goto l34
					}
					goto l31
				l34:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleSET_NOTIN]() {
						goto l29
					}
					if !_rules[ruleSpace]() {
						goto l29
					}
					if !_rules[ruleExpr]() {
						goto l29
					}
					if !_rules[ruleAction11]() {
						goto l29
					}
				}
			l31:
				add(ruleQuerySessionContext, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 7 Statements <- <(Statement (Space PIPE Space Statement)*)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleStatement]() {
					goto l35
				}
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l38
					}
					if !_rules[rulePIPE]() {
						goto l38
					}
					if !_rules[ruleSpace]() {
						goto l38
					}
					if !_rules[ruleStatement]() {
						goto l38
					}
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
				add(ruleStatements, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 8 Statement <- <(((('f' 'i' 'l' 't' 'e' 'r') / ('w' 'h' 'e' 'r' 'e')) MustSpace FilterOperator Action12) / ('s' 'u' 'm' 'm' 'a' 'r' 'i' 'z' 'e' MustSpace SummarizeOperator Action13) / ('p' 'r' 'o' 'j' 'e' 'c' 't' MustSpace ProjectOperator Action14))> */
		func() bool {
			position39, tokenIndex39 := position, tokenIndex
			{
				position40 := position
				{
					position41, tokenIndex41 := position, tokenIndex
					{
						position43, tokenIndex43 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l44
						}
						position++
						if buffer[position] != rune('i') {
							goto l44
						}
						position++
						if buffer[position] != rune('l') {
							goto l44
						}
						position++
						if buffer[position] != rune('t') {
							goto l44
						}
						position++
						if buffer[position] != rune('e') {
							goto l44
						}
						position++
						if buffer[position] != rune('r') {
							goto l44
						}
						position++
						goto l43
					l44:
						position, tokenIndex = position43, tokenIndex43
						if buffer[position] != rune('w') {
							goto l42
						}
						position++
						if buffer[position] != rune('h') {
							goto l42
						}
						position++
						if buffer[position] != rune('e') {
							goto l42
						}
						position++
						if buffer[position] != rune('r') {
							goto l42
						}
						position++
						if buffer[position] != rune('e') {
							goto l42
						}
						position++
					}
				l43:
					if !_rules[ruleMustSpace]() {
						goto l42
					}
					if !_rules[ruleFilterOperator]() {
						goto l42
					}
					if !_rules[ruleAction12]() {
						goto l42
					}
					goto l41
				l42:
					position, tokenIndex = position41, tokenIndex41
					if buffer[position] != rune('s') {
						goto l45
					}
					position++
					if buffer[position] != rune('u') {
						goto l45
					}
					position++
					if buffer[position] != rune('m') {
						goto l45
					}
					position++
					if buffer[position] != rune('m') {
						goto l45
					}
					position++
					if buffer[position] != rune('a') {
						goto l45
					}
					position++
					if buffer[position] != rune('r') {
						goto l45
					}
					position++
					if buffer[position] != rune('i') {
						goto l45
					}
					position++
					if buffer[position] != rune('z') {
						goto l45
					}
					position++
					if buffer[position] != rune('e') {
						goto l45
					}
					position++
					if !_rules[ruleMustSpace]() {
						goto l45
					}
					if !_rules[ruleSummarizeOperator]() {
						goto l45
					}
					if !_rules[ruleAction13]() {
						goto l45
					}
					goto l41
				l45:
					position, tokenIndex = position41, tokenIndex41
					if buffer[position] != rune('p') {
						goto l39
					}
					position++
					if buffer[position] != rune('r') {
						goto l39
					}
					position++
					if buffer[position] != rune('o') {
						goto l39
					}
					position++
					if buffer[position] != rune('j') {
						goto l39
					}
					position++
					if buffer[position] != rune('e') {
						goto l39
					}
					position++
					if buffer[position] != rune('c') {
						goto l39
					}
					position++
					if buffer[position] != rune('t') {
						goto l39
					}
					position++
					if !_rules[ruleMustSpace]() {
						goto l39
					}
					if !_rules[ruleProjectOperator]() {
						goto l39
					}
					if !_rules[ruleAction14]() {
						goto l39
					}
				}
			l41:
				add(ruleStatement, position40)
			}
			return true
		l39:
			position, tokenIndex = position39, tokenIndex39
			return false
		},
		/* 9 FilterOperator <- <(Expr Action15)> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
				if !_rules[ruleExpr]() {
					goto l46
				}
				if !_rules[ruleAction15]() {
					goto l46
				}
				add(ruleFilterOperator, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 10 SummarizeOperator <- <(FuncCall Action16 ByOperator?)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleFuncCall]() {
					goto l48
				}
				if !_rules[ruleAction16]() {
					goto l48
				}
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleByOperator]() {
						goto l50
					}
					goto l51
				l50:
					position, tokenIndex = position50, tokenIndex50
				}
			l51:
				add(ruleSummarizeOperator, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 11 ByOperator <- <('b' 'y' MustSpace ByOperatorArg (Space ',' Space ByOperatorArg)* Space)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if buffer[position] != rune('b') {
					goto l52
				}
				position++
				if buffer[position] != rune('y') {
					goto l52
				}
				position++
				if !_rules[ruleMustSpace]() {
					goto l52
				}
				if !_rules[ruleByOperatorArg]() {
					goto l52
				}
			l54:
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l55
					}
					if buffer[position] != rune(',') {
						goto l55
					}
					position++
					if !_rules[ruleSpace]() {
						goto l55
					}
					if !_rules[ruleByOperatorArg]() {
						goto l55
					}
					goto l54
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
				if !_rules[ruleSpace]() {
					goto l52
				}
				add(ruleByOperator, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 ByOperatorArg <- <(Expr Action17)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleExpr]() {
					goto l56
				}
				if !_rules[ruleAction17]() {
					goto l56
				}
				add(ruleByOperatorArg, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 ProjectOperator <- <(Action18 ProjectArg (Space ',' Space ProjectArg)* Space)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				if !_rules[ruleAction18]() {
					goto l58
				}
				if !_rules[ruleProjectArg]() {
					goto l58
				}
			l60:
				{
					position61, tokenIndex61 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l61
					}
					if buffer[position] != rune(',') {
						goto l61
					}
					position++
					if !_rules[ruleSpace]() {
						goto l61
					}
					if !_rules[ruleProjectArg]() {
						goto l61
					}
					goto l60
				l61:
					position, tokenIndex = position61, tokenIndex61
				}
				if !_rules[ruleSpace]() {
					goto l58
				}
				add(ruleProjectOperator, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 14 ProjectArg <- <(Identifier Action19 (Space '=' Space Expr)? Action20)> */
		func() bool {
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				if !_rules[ruleIdentifier]() {
					goto l62
				}
				if !_rules[ruleAction19]() {
					goto l62
				}
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l64
					}
					if buffer[position] != rune('=') {
						goto l64
					}
					position++
					if !_rules[ruleSpace]() {
						goto l64
					}
					if !_rules[ruleExpr]() {
						goto l64
					}
					goto l65
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
			l65:
				if !_rules[ruleAction20]() {
					goto l62
				}
				add(ruleProjectArg, position63)
			}
			return true
		l62:
			position, tokenIndex = position62, tokenIndex62
			return false
		},
		/* 15 Expr <- <(Expr1 ((Space NUM_ADD Expr1 Space Action21) / (Space NUM_SUB Expr1 Space Action22))*)> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				if !_rules[ruleExpr1]() {
					goto l66
				}
			l68:
				{
					position69, tokenIndex69 := position, tokenIndex
					{
						position70, tokenIndex70 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l71
						}
						if !_rules[ruleNUM_ADD]() {
							goto l71
						}
						if !_rules[ruleExpr1]() {
							goto l71
						}
						if !_rules[ruleSpace]() {
							goto l71
						}
						if !_rules[ruleAction21]() {
							goto l71
						}
						goto l70
					l71:
						position, tokenIndex = position70, tokenIndex70
						if !_rules[ruleSpace]() {
							goto l69
						}
						if !_rules[ruleNUM_SUB]() {
							goto l69
						}
						if !_rules[ruleExpr1]() {
							goto l69
						}
						if !_rules[ruleSpace]() {
							goto l69
						}
						if !_rules[ruleAction22]() {
							goto l69
						}
					}
				l70:
					goto l68
				l69:
					position, tokenIndex = position69, tokenIndex69
				}
				add(ruleExpr, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 16 Expr1 <- <(Expr2 ((Space NUM_MUL Expr2 Space Action23) / (Space NUM_DIV Expr2 Space Action24))*)> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				if !_rules[ruleExpr2]() {
					goto l72
				}
			l74:
				{
					position75, tokenIndex75 := position, tokenIndex
					{
						position76, tokenIndex76 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l77
						}
						if !_rules[ruleNUM_MUL]() {
							goto l77
						}
						if !_rules[ruleExpr2]() {
							goto l77
						}
						if !_rules[ruleSpace]() {
							goto l77
						}
						if !_rules[ruleAction23]() {
							goto l77
						}
						goto l76
					l77:
						position, tokenIndex = position76, tokenIndex76
						if !_rules[ruleSpace]() {
							goto l75
						}
						if !_rules[ruleNUM_DIV]() {
							goto l75
						}
						if !_rules[ruleExpr2]() {
							goto l75
						}
						if !_rules[ruleSpace]() {
							goto l75
						}
						if !_rules[ruleAction24]() {
							goto l75
						}
					}
				l76:
					goto l74
				l75:
					position, tokenIndex = position75, tokenIndex75
				}
				add(ruleExpr1, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 17 Expr2 <- <(Expr3 ((Space LOG_AND Expr3 Space Action25) / (Space LOG_OR Expr3 Space Action26))*)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if !_rules[ruleExpr3]() {
					goto l78
				}
			l80:
				{
					position81, tokenIndex81 := position, tokenIndex
					{
						position82, tokenIndex82 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l83
						}
						if !_rules[ruleLOG_AND]() {
							goto l83
						}
						if !_rules[ruleExpr3]() {
							goto l83
						}
						if !_rules[ruleSpace]() {
							goto l83
						}
						if !_rules[ruleAction25]() {
							goto l83
						}
						goto l82
					l83:
						position, tokenIndex = position82, tokenIndex82
						if !_rules[ruleSpace]() {
							goto l81
						}
						if !_rules[ruleLOG_OR]() {
							goto l81
						}
						if !_rules[ruleExpr3]() {
							goto l81
						}
						if !_rules[ruleSpace]() {
							goto l81
						}
						if !_rules[ruleAction26]() {
							goto l81
						}
					}
				l82:
					goto l80
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
				add(ruleExpr2, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 18 Expr3 <- <(Expr4 ((Space CMP_EQ Expr4 Action27) / (Space CMP_NOTEQ Expr4 Action28) / (Space CMP_GT Expr4 Action29) / (Space CMP_GTE Expr4 Action30) / (Space CMP_LT Expr4 Action31) / (Space CMP_LTE Expr4 Action32) / (Space SET_IN Expr4 Action33) / (Space SET_NOTIN Expr4 Action34))*)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				if !_rules[ruleExpr4]() {
					goto l84
				}
			l86:
				{
					position87, tokenIndex87 := position, tokenIndex
					{
						position88, tokenIndex88 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l89
						}
						if !_rules[ruleCMP_EQ]() {
							goto l89
						}
						if !_rules[ruleExpr4]() {
							goto l89
						}
						if !_rules[ruleAction27]() {
							goto l89
						}
						goto l88
					l89:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l90
						}
						if !_rules[ruleCMP_NOTEQ]() {
							goto l90
						}
						if !_rules[ruleExpr4]() {
							goto l90
						}
						if !_rules[ruleAction28]() {
							goto l90
						}
						goto l88
					l90:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l91
						}
						if !_rules[ruleCMP_GT]() {
							goto l91
						}
						if !_rules[ruleExpr4]() {
							goto l91
						}
						if !_rules[ruleAction29]() {
							goto l91
						}
						goto l88
					l91:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l92
						}
						if !_rules[ruleCMP_GTE]() {
							goto l92
						}
						if !_rules[ruleExpr4]() {
							goto l92
						}
						if !_rules[ruleAction30]() {
							goto l92
						}
						goto l88
					l92:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l93
						}
						if !_rules[ruleCMP_LT]() {
							goto l93
						}
						if !_rules[ruleExpr4]() {
							goto l93
						}
						if !_rules[ruleAction31]() {
							goto l93
						}
						goto l88
					l93:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l94
						}
						if !_rules[ruleCMP_LTE]() {
							goto l94
						}
						if !_rules[ruleExpr4]() {
							goto l94
						}
						if !_rules[ruleAction32]() {
							goto l94
						}
						goto l88
					l94:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l95
						}
						if !_rules[ruleSET_IN]() {
							goto l95
						}
						if !_rules[ruleExpr4]() {
							goto l95
						}
						if !_rules[ruleAction33]() {
							goto l95
						}
						goto l88
					l95:
						position, tokenIndex = position88, tokenIndex88
						if !_rules[ruleSpace]() {
							goto l87
						}
						if !_rules[ruleSET_NOTIN]() {
							goto l87
						}
						if !_rules[ruleExpr4]() {
							goto l87
						}
						if !_rules[ruleAction34]() {
							goto l87
						}
					}
				l88:
					goto l86
				l87:
					position, tokenIndex = position87, tokenIndex87
				}
				add(ruleExpr3, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 19 Expr4 <- <(Expr5 ((Space L_BRACKET Expr5 R_BRACKET Action35) / (Space DOT <SelectorId> Action36))*)> */
		func() bool {
			position96, tokenIndex96 := position, tokenIndex
			{
				position97 := position
				if !_rules[ruleExpr5]() {
					goto l96
				}
			l98:
				{
					position99, tokenIndex99 := position, tokenIndex
					{
						position100, tokenIndex100 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l101
						}
						if !_rules[ruleL_BRACKET]() {
							goto l101
						}
						if !_rules[ruleExpr5]() {
							goto l101
						}
						if !_rules[ruleR_BRACKET]() {
							goto l101
						}
						if !_rules[ruleAction35]() {
							goto l101
						}
						goto l100
					l101:
						position, tokenIndex = position100, tokenIndex100
						if !_rules[ruleSpace]() {
							goto l99
						}
						if !_rules[ruleDOT]() {
							goto l99
						}
						{
							position102 := position
							if !_rules[ruleSelectorId]() {
								goto l99
							}
							add(rulePegText, position102)
						}
						if !_rules[ruleAction36]() {
							goto l99
						}
					}
				l100:
					goto l98
				l99:
					position, tokenIndex = position99, tokenIndex99
				}
				add(ruleExpr4, position97)
			}
			return true
		l96:
			position, tokenIndex = position96, tokenIndex96
			return false
		},
		/* 20 Expr5 <- <((L_PARENS Expr R_PARENS Space) / (NOT Literal Space Action37) / (NOT L_PARENS Expr R_PARENS Space Action38) / (NEG Literal Space Action39) / (NEG L_PARENS Expr R_PARENS Space Action40) / (Literal Space Action41) / (FuncCall Space Action42) / (Identifier Space))> */
		func() bool {
			position103, tokenIndex103 := position, tokenIndex
			{
				position104 := position
				{
					position105, tokenIndex105 := position, tokenIndex
					if !_rules[ruleL_PARENS]() {
						goto l106
					}
					if !_rules[ruleExpr]() {
						goto l106
					}
					if !_rules[ruleR_PARENS]() {
						goto l106
					}
					if !_rules[ruleSpace]() {
						goto l106
					}
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleNOT]() {
						goto l107
					}
					if !_rules[ruleLiteral]() {
						goto l107
					}
					if !_rules[ruleSpace]() {
						goto l107
					}
					if !_rules[ruleAction37]() {
						goto l107
					}
					goto l105
				l107:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleNOT]() {
						goto l108
					}
					if !_rules[ruleL_PARENS]() {
						goto l108
					}
					if !_rules[ruleExpr]() {
						goto l108
					}
					if !_rules[ruleR_PARENS]() {
						goto l108
					}
					if !_rules[ruleSpace]() {
						goto l108
					}
					if !_rules[ruleAction38]() {
						goto l108
					}
					goto l105
				l108:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleNEG]() {
						goto l109
					}
					if !_rules[ruleLiteral]() {
						goto l109
					}
					if !_rules[ruleSpace]() {
						goto l109
					}
					if !_rules[ruleAction39]() {
						goto l109
					}
					goto l105
				l109:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleNEG]() {
						goto l110
					}
					if !_rules[ruleL_PARENS]() {
						goto l110
					}
					if !_rules[ruleExpr]() {
						goto l110
					}
					if !_rules[ruleR_PARENS]() {
						goto l110
					}
					if !_rules[ruleSpace]() {
						goto l110
					}
					if !_rules[ruleAction40]() {
						goto l110
					}
					goto l105
				l110:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleLiteral]() {
						goto l111
					}
					if !_rules[ruleSpace]() {
						goto l111
					}
					if !_rules[ruleAction41]() {
						goto l111
					}
					goto l105
				l111:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleFuncCall]() {
						goto l112
					}
					if !_rules[ruleSpace]() {
						goto l112
					}
					if !_rules[ruleAction42]() {
						goto l112
					}
					goto l105
				l112:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleIdentifier]() {
						goto l103
					}
					if !_rules[ruleSpace]() {
						goto l103
					}
				}
			l105:
				add(ruleExpr5, position104)
			}
			return true
		l103:
			position, tokenIndex = position103, tokenIndex103
			return false
		},
		/* 21 Literal <- <((String Action43) / (('d' 'u' 'r' ':')? Duration Action44) / (('t' 's' ':')? Timestamp Action45) / (F64 Action46) / (I64 Action47) / (Bool Action48) / (Array Action49) / (Object Action50))> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				{
					position115, tokenIndex115 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l116
					}
					if !_rules[ruleAction43]() {
						goto l116
					}
					goto l115
				l116:
					position, tokenIndex = position115, tokenIndex115
					{
						position118, tokenIndex118 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l118
						}
						position++
						if buffer[position] != rune('u') {
							goto l118
						}
						position++
						if buffer[position] != rune('r') {
							goto l118
						}
						position++
						if buffer[position] != rune(':') {
							goto l118
						}
						position++
						goto l119
					l118:
						position, tokenIndex = position118, tokenIndex118
					}
				l119:
					if !_rules[ruleDuration]() {
						goto l117
					}
					if !_rules[ruleAction44]() {
						goto l117
					}
					goto l115
				l117:
					position, tokenIndex = position115, tokenIndex115
					{
						position121, tokenIndex121 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l121
						}
						position++
						if buffer[position] != rune('s') {
							goto l121
						}
						position++
						if buffer[position] != rune(':') {
							goto l121
						}
						position++
						goto l122
					l121:
						position, tokenIndex = position121, tokenIndex121
					}
				l122:
					if !_rules[ruleTimestamp]() {
						goto l120
					}
					if !_rules[ruleAction45]() {
						goto l120
					}
					goto l115
				l120:
					position, tokenIndex = position115, tokenIndex115
					if !_rules[ruleF64]() {
						goto l123
					}
					if !_rules[ruleAction46]() {
						goto l123
					}
					goto l115
				l123:
					position, tokenIndex = position115, tokenIndex115
					if !_rules[ruleI64]() {
						goto l124
					}
					if !_rules[ruleAction47]() {
						goto l124
					}
					goto l115
				l124:
					position, tokenIndex = position115, tokenIndex115
					if !_rules[ruleBool]() {
						goto l125
					}
					if !_rules[ruleAction48]() {
						goto l125
					}
					goto l115
				l125:
					position, tokenIndex = position115, tokenIndex115
					if !_rules[ruleArray]() {
						goto l126
					}
					if !_rules[ruleAction49]() {
						goto l126
					}
					goto l115
				l126:
					position, tokenIndex = position115, tokenIndex115
					if !_rules[ruleObject]() {
						goto l113
					}
					if !_rules[ruleAction50]() {
						goto l113
					}
				}
			l115:
				add(ruleLiteral, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 22 FuncCall <- <(Action51 FuncName '(' FuncArgs? ')' Space)> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				if !_rules[ruleAction51]() {
					goto l127
				}
				if !_rules[ruleFuncName]() {
					goto l127
				}
				if buffer[position] != rune('(') {
					goto l127
				}
				position++
				{
					position129, tokenIndex129 := position, tokenIndex
					if !_rules[ruleFuncArgs]() {
						goto l129
					}
					goto l130
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
			l130:
				if buffer[position] != rune(')') {
					goto l127
				}
				position++
				if !_rules[ruleSpace]() {
					goto l127
				}
				add(ruleFuncCall, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 23 FuncName <- <(!ReservedKeyword <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / '_' / [0-9])*)> Action52)> */
		func() bool {
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				{
					position133, tokenIndex133 := position, tokenIndex
					if !_rules[ruleReservedKeyword]() {
						goto l133
					}
					goto l131
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				{
					position134 := position
					{
						position135, tokenIndex135 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l136
						}
						position++
						goto l135
					l136:
						position, tokenIndex = position135, tokenIndex135
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l137
						}
						position++
						goto l135
					l137:
						position, tokenIndex = position135, tokenIndex135
						if buffer[position] != rune('_') {
							goto l131
						}
						position++
					}
				l135:
				l138:
					{
						position139, tokenIndex139 := position, tokenIndex
						{
							position140, tokenIndex140 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l141
							}
							position++
							goto l140
						l141:
							position, tokenIndex = position140, tokenIndex140
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l142
							}
							position++
							goto l140
						l142:
							position, tokenIndex = position140, tokenIndex140
							if buffer[position] != rune('_') {
								goto l143
							}
							position++
							goto l140
						l143:
							position, tokenIndex = position140, tokenIndex140
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l139
							}
							position++
						}
					l140:
						goto l138
					l139:
						position, tokenIndex = position139, tokenIndex139
					}
					add(rulePegText, position134)
				}
				if !_rules[ruleAction52]() {
					goto l131
				}
				add(ruleFuncName, position132)
			}
			return true
		l131:
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 24 FuncArgs <- <(FuncArg (Space ',' Space FuncArg)* Space)> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if !_rules[ruleFuncArg]() {
					goto l144
				}
			l146:
				{
					position147, tokenIndex147 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l147
					}
					if buffer[position] != rune(',') {
						goto l147
					}
					position++
					if !_rules[ruleSpace]() {
						goto l147
					}
					if !_rules[ruleFuncArg]() {
						goto l147
					}
					goto l146
				l147:
					position, tokenIndex = position147, tokenIndex147
				}
				if !_rules[ruleSpace]() {
					goto l144
				}
				add(ruleFuncArgs, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 25 FuncArg <- <(Expr Action53)> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				if !_rules[ruleExpr]() {
					goto l148
				}
				if !_rules[ruleAction53]() {
					goto l148
				}
				add(ruleFuncArg, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 26 Identifier <- <(<(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> Action54)> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				{
					position152 := position
					{
						position153, tokenIndex153 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l154
						}
						position++
						goto l153
					l154:
						position, tokenIndex = position153, tokenIndex153
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l155
						}
						position++
						goto l153
					l155:
						position, tokenIndex = position153, tokenIndex153
						if buffer[position] != rune('_') {
							goto l150
						}
						position++
					}
				l153:
				l156:
					{
						position157, tokenIndex157 := position, tokenIndex
						{
							position158, tokenIndex158 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l159
							}
							position++
							goto l158
						l159:
							position, tokenIndex = position158, tokenIndex158
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l160
							}
							position++
							goto l158
						l160:
							position, tokenIndex = position158, tokenIndex158
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l161
							}
							position++
							goto l158
						l161:
							position, tokenIndex = position158, tokenIndex158
							if buffer[position] != rune('_') {
								goto l157
							}
							position++
						}
					l158:
						goto l156
					l157:
						position, tokenIndex = position157, tokenIndex157
					}
					add(rulePegText, position152)
				}
				if !_rules[ruleAction54]() {
					goto l150
				}
				add(ruleIdentifier, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 27 String <- <(<('"' StringChar* '"')> Action55)> */
		func() bool {
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164 := position
					if buffer[position] != rune('"') {
						goto l162
					}
					position++
				l165:
					{
						position166, tokenIndex166 := position, tokenIndex
						if !_rules[ruleStringChar]() {
							goto l166
						}
						goto l165
					l166:
						position, tokenIndex = position166, tokenIndex166
					}
					if buffer[position] != rune('"') {
						goto l162
					}
					position++
					add(rulePegText, position164)
				}
				if !_rules[ruleAction55]() {
					goto l162
				}
				add(ruleString, position163)
			}
			return true
		l162:
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 28 SelectorId <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				{
					position169, tokenIndex169 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l170
					}
					position++
					goto l169
				l170:
					position, tokenIndex = position169, tokenIndex169
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l171
					}
					position++
					goto l169
				l171:
					position, tokenIndex = position169, tokenIndex169
					if buffer[position] != rune('_') {
						goto l167
					}
					position++
				}
			l169:
			l172:
				{
					position173, tokenIndex173 := position, tokenIndex
					{
						position174, tokenIndex174 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l175
						}
						position++
						goto l174
					l175:
						position, tokenIndex = position174, tokenIndex174
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l176
						}
						position++
						goto l174
					l176:
						position, tokenIndex = position174, tokenIndex174
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l177
						}
						position++
						goto l174
					l177:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('_') {
							goto l173
						}
						position++
					}
				l174:
					goto l172
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
				add(ruleSelectorId, position168)
			}
			return true
		l167:
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 29 F64 <- <((<(Digits '.' Digits? Exponent?)> Action56) / (<('.' Digits Exponent?)> Action57) / (<(Digits Exponent)> Action58))> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				{
					position180, tokenIndex180 := position, tokenIndex
					{
						position182 := position
						if !_rules[ruleDigits]() {
							goto l181
						}
						if buffer[position] != rune('.') {
							goto l181
						}
						position++
						{
							position183, tokenIndex183 := position, tokenIndex
							if !_rules[ruleDigits]() {
								goto l183
							}
							goto l184
						l183:
							position, tokenIndex = position183, tokenIndex183
						}
					l184:
						{
							position185, tokenIndex185 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l185
							}
							goto l186
						l185:
							position, tokenIndex = position185, tokenIndex185
						}
					l186:
						add(rulePegText, position182)
					}
					if !_rules[ruleAction56]() {
						goto l181
					}
					goto l180
				l181:
					position, tokenIndex = position180, tokenIndex180
					{
						position188 := position
						if buffer[position] != rune('.') {
							goto l187
						}
						position++
						if !_rules[ruleDigits]() {
							goto l187
						}
						{
							position189, tokenIndex189 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l189
							}
							goto l190
						l189:
							position, tokenIndex = position189, tokenIndex189
						}
					l190:
						add(rulePegText, position188)
					}
					if !_rules[ruleAction57]() {
						goto l187
					}
					goto l180
				l187:
					position, tokenIndex = position180, tokenIndex180
					{
						position191 := position
						if !_rules[ruleDigits]() {
							goto l178
						}
						if !_rules[ruleExponent]() {
							goto l178
						}
						add(rulePegText, position191)
					}
					if !_rules[ruleAction58]() {
						goto l178
					}
				}
			l180:
				add(ruleF64, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 30 I64 <- <(('0' Action59) / (<([1-9] ('_'* [0-9])*)> Action60))> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l195
					}
					position++
					if !_rules[ruleAction59]() {
						goto l195
					}
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					{
						position196 := position
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l192
						}
						position++
					l197:
						{
							position198, tokenIndex198 := position, tokenIndex
						l199:
							{
								position200, tokenIndex200 := position, tokenIndex
								if buffer[position] != rune('_') {
									goto l200
								}
								position++
								goto l199
							l200:
								position, tokenIndex = position200, tokenIndex200
							}
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l198
							}
							position++
							goto l197
						l198:
							position, tokenIndex = position198, tokenIndex198
						}
						add(rulePegText, position196)
					}
					if !_rules[ruleAction60]() {
						goto l192
					}
				}
			l194:
				add(ruleI64, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 31 Bool <- <(('t' 'r' 'u' 'e' Action61) / ('f' 'a' 'l' 's' 'e' Action62))> */
		func() bool {
			position201, tokenIndex201 := position, tokenIndex
			{
				position202 := position
				{
					position203, tokenIndex203 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l204
					}
					position++
					if buffer[position] != rune('r') {
						goto l204
					}
					position++
					if buffer[position] != rune('u') {
						goto l204
					}
					position++
					if buffer[position] != rune('e') {
						goto l204
					}
					position++
					if !_rules[ruleAction61]() {
						goto l204
					}
					goto l203
				l204:
					position, tokenIndex = position203, tokenIndex203
					if buffer[position] != rune('f') {
						goto l201
					}
					position++
					if buffer[position] != rune('a') {
						goto l201
					}
					position++
					if buffer[position] != rune('l') {
						goto l201
					}
					position++
					if buffer[position] != rune('s') {
						goto l201
					}
					position++
					if buffer[position] != rune('e') {
						goto l201
					}
					position++
					if !_rules[ruleAction62]() {
						goto l201
					}
				}
			l203:
				add(ruleBool, position202)
			}
			return true
		l201:
			position, tokenIndex = position201, tokenIndex201
			return false
		},
		/* 32 ReservedKeyword <- <(('l' 'v' 'l') / ('m' 's' 'g') / ('k' 'v') / Bool)> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				{
					position207, tokenIndex207 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l208
					}
					position++
					if buffer[position] != rune('v') {
						goto l208
					}
					position++
					if buffer[position] != rune('l') {
						goto l208
					}
					position++
					goto l207
				l208:
					position, tokenIndex = position207, tokenIndex207
					if buffer[position] != rune('m') {
						goto l209
					}
					position++
					if buffer[position] != rune('s') {
						goto l209
					}
					position++
					if buffer[position] != rune('g') {
						goto l209
					}
					position++
					goto l207
				l209:
					position, tokenIndex = position207, tokenIndex207
					if buffer[position] != rune('k') {
						goto l210
					}
					position++
					if buffer[position] != rune('v') {
						goto l210
					}
					position++
					goto l207
				l210:
					position, tokenIndex = position207, tokenIndex207
					if !_rules[ruleBool]() {
						goto l205
					}
				}
			l207:
				add(ruleReservedKeyword, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 33 Array <- <(L_BRACKET Action63 (ArrayItem (COMMA ArrayItem)*)? R_BRACKET)> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if !_rules[ruleL_BRACKET]() {
					goto l211
				}
				if !_rules[ruleAction63]() {
					goto l211
				}
				{
					position213, tokenIndex213 := position, tokenIndex
					if !_rules[ruleArrayItem]() {
						goto l213
					}
				l215:
					{
						position216, tokenIndex216 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l216
						}
						if !_rules[ruleArrayItem]() {
							goto l216
						}
						goto l215
					l216:
						position, tokenIndex = position216, tokenIndex216
					}
					goto l214
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
			l214:
				if !_rules[ruleR_BRACKET]() {
					goto l211
				}
				add(ruleArray, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 34 ArrayItem <- <(Literal Action64)> */
		func() bool {
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if !_rules[ruleLiteral]() {
					goto l217
				}
				if !_rules[ruleAction64]() {
					goto l217
				}
				add(ruleArrayItem, position218)
			}
			return true
		l217:
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 35 Object <- <(L_SQUIGGLY Action65 (ObjectItem (COMMA ObjectItem)*)? R_SQUIGGLY)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l219
				}
				if !_rules[ruleAction65]() {
					goto l219
				}
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleObjectItem]() {
						goto l221
					}
				l223:
					{
						position224, tokenIndex224 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l224
						}
						if !_rules[ruleObjectItem]() {
							goto l224
						}
						goto l223
					l224:
						position, tokenIndex = position224, tokenIndex224
					}
					goto l222
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
			l222:
				if !_rules[ruleR_SQUIGGLY]() {
					goto l219
				}
				add(ruleObject, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 36 ObjectItem <- <(ObjectKey COLON Literal Action66)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				if !_rules[ruleObjectKey]() {
					goto l225
				}
				if !_rules[ruleCOLON]() {
					goto l225
				}
				if !_rules[ruleLiteral]() {
					goto l225
				}
				if !_rules[ruleAction66]() {
					goto l225
				}
				add(ruleObjectItem, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 37 ObjectKey <- <(String Action67)> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				if !_rules[ruleString]() {
					goto l227
				}
				if !_rules[ruleAction67]() {
					goto l227
				}
				add(ruleObjectKey, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 38 Duration <- <((F64 <(('u' 's') / ('' 's') / ('m' 's') / 's' / 'm' / 'h')> Action68) / (I64 <(('n' 's') / ('u' 's') / ('' 's') / ('m' 's') / 's' / 'm' / 'h')> Action69))> */
		func() bool {
			position229, tokenIndex229 := position, tokenIndex
			{
				position230 := position
				{
					position231, tokenIndex231 := position, tokenIndex
					if !_rules[ruleF64]() {
						goto l232
					}
					{
						position233 := position
						{
							position234, tokenIndex234 := position, tokenIndex
							if buffer[position] != rune('u') {
								goto l235
							}
							position++
							if buffer[position] != rune('s') {
								goto l235
							}
							position++
							goto l234
						l235:
							position, tokenIndex = position234, tokenIndex234
							if buffer[position] != rune('') {
								goto l236
							}
							position++
							if buffer[position] != rune('s') {
								goto l236
							}
							position++
							goto l234
						l236:
							position, tokenIndex = position234, tokenIndex234
							if buffer[position] != rune('m') {
								goto l237
							}
							position++
							if buffer[position] != rune('s') {
								goto l237
							}
							position++
							goto l234
						l237:
							position, tokenIndex = position234, tokenIndex234
							if buffer[position] != rune('s') {
								goto l238
							}
							position++
							goto l234
						l238:
							position, tokenIndex = position234, tokenIndex234
							if buffer[position] != rune('m') {
								goto l239
							}
							position++
							goto l234
						l239:
							position, tokenIndex = position234, tokenIndex234
							if buffer[position] != rune('h') {
								goto l232
							}
							position++
						}
					l234:
						add(rulePegText, position233)
					}
					if !_rules[ruleAction68]() {
						goto l232
					}
					goto l231
				l232:
					position, tokenIndex = position231, tokenIndex231
					if !_rules[ruleI64]() {
						goto l229
					}
					{
						position240 := position
						{
							position241, tokenIndex241 := position, tokenIndex
							if buffer[position] != rune('n') {
								goto l242
							}
							position++
							if buffer[position] != rune('s') {
								goto l242
							}
							position++
							goto l241
						l242:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('u') {
								goto l243
							}
							position++
							if buffer[position] != rune('s') {
								goto l243
							}
							position++
							goto l241
						l243:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('') {
								goto l244
							}
							position++
							if buffer[position] != rune('s') {
								goto l244
							}
							position++
							goto l241
						l244:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('m') {
								goto l245
							}
							position++
							if buffer[position] != rune('s') {
								goto l245
							}
							position++
							goto l241
						l245:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('s') {
								goto l246
							}
							position++
							goto l241
						l246:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('m') {
								goto l247
							}
							position++
							goto l241
						l247:
							position, tokenIndex = position241, tokenIndex241
							if buffer[position] != rune('h') {
								goto l229
							}
							position++
						}
					l241:
						add(rulePegText, position240)
					}
					if !_rules[ruleAction69]() {
						goto l229
					}
				}
			l231:
				add(ruleDuration, position230)
			}
			return true
		l229:
			position, tokenIndex = position229, tokenIndex229
			return false
		},
		/* 39 Timestamp <- <(<RFC3339Nano> Action70)> */
		func() bool {
			position248, tokenIndex248 := position, tokenIndex
			{
				position249 := position
				{
					position250 := position
					if !_rules[ruleRFC3339Nano]() {
						goto l248
					}
					add(rulePegText, position250)
				}
				if !_rules[ruleAction70]() {
					goto l248
				}
				add(ruleTimestamp, position249)
			}
			return true
		l248:
			position, tokenIndex = position248, tokenIndex248
			return false
		},
		/* 40 StringChar <- <(('\\' ('\'' / '"' / '?' / '\\' / '%' / 'a' / 'b' / 'f' / 'n' / 'r' / 't' / 'v')) / (!('"' / '\n' / '\\') .))> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				{
					position253, tokenIndex253 := position, tokenIndex
					if buffer[position] != rune('\\') {
						goto l254
					}
					position++
					{
						position255, tokenIndex255 := position, tokenIndex
						if buffer[position] != rune('\'') {
							goto l256
						}
						position++
						goto l255
					l256:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('"') {
							goto l257
						}
						position++
						goto l255
					l257:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('?') {
							goto l258
						}
						position++
						goto l255
					l258:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('\\') {
							goto l259
						}
						position++
						goto l255
					l259:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('%') {
							goto l260
						}
						position++
						goto l255
					l260:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('a') {
							goto l261
						}
						position++
						goto l255
					l261:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('b') {
							goto l262
						}
						position++
						goto l255
					l262:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('f') {
							goto l263
						}
						position++
						goto l255
					l263:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('n') {
							goto l264
						}
						position++
						goto l255
					l264:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('r') {
							goto l265
						}
						position++
						goto l255
					l265:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('t') {
							goto l266
						}
						position++
						goto l255
					l266:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('v') {
							goto l254
						}
						position++
					}
				l255:
					goto l253
				l254:
					position, tokenIndex = position253, tokenIndex253
					{
						position267, tokenIndex267 := position, tokenIndex
						{
							position268, tokenIndex268 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l269
							}
							position++
							goto l268
						l269:
							position, tokenIndex = position268, tokenIndex268
							if buffer[position] != rune('\n') {
								goto l270
							}
							position++
							goto l268
						l270:
							position, tokenIndex = position268, tokenIndex268
							if buffer[position] != rune('\\') {
								goto l267
							}
							position++
						}
					l268:
						goto l251
					l267:
						position, tokenIndex = position267, tokenIndex267
					}
					if !matchDot() {
						goto l251
					}
				}
			l253:
				add(ruleStringChar, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 41 Exponent <- <(('e' / 'E') ('+' / '-')? Digits)> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				{
					position273, tokenIndex273 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l274
					}
					position++
					goto l273
				l274:
					position, tokenIndex = position273, tokenIndex273
					if buffer[position] != rune('E') {
						goto l271
					}
					position++
				}
			l273:
				{
					position275, tokenIndex275 := position, tokenIndex
					{
						position277, tokenIndex277 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l278
						}
						position++
						goto l277
					l278:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('-') {
							goto l275
						}
						position++
					}
				l277:
					goto l276
				l275:
					position, tokenIndex = position275, tokenIndex275
				}
			l276:
				if !_rules[ruleDigits]() {
					goto l271
				}
				add(ruleExponent, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 42 Digits <- <([0-9] ('_'* [0-9])*)> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l279
				}
				position++
			l281:
				{
					position282, tokenIndex282 := position, tokenIndex
				l283:
					{
						position284, tokenIndex284 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l284
						}
						position++
						goto l283
					l284:
						position, tokenIndex = position284, tokenIndex284
					}
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l282
					}
					position++
					goto l281
				l282:
					position, tokenIndex = position282, tokenIndex282
				}
				add(ruleDigits, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 43 RFC3339Nano <- <(RFC3339NanoDate 'T' RFC3339NanoTime RFC3339NanoTimezone)> */
		func() bool {
			position285, tokenIndex285 := position, tokenIndex
			{
				position286 := position
				if !_rules[ruleRFC3339NanoDate]() {
					goto l285
				}
				if buffer[position] != rune('T') {
					goto l285
				}
				position++
				if !_rules[ruleRFC3339NanoTime]() {
					goto l285
				}
				if !_rules[ruleRFC3339NanoTimezone]() {
					goto l285
				}
				add(ruleRFC3339Nano, position286)
			}
			return true
		l285:
			position, tokenIndex = position285, tokenIndex285
			return false
		},
		/* 44 RFC3339NanoDate <- <(Number '-' Number '-' Number)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if !_rules[ruleNumber]() {
					goto l287
				}
				if buffer[position] != rune('-') {
					goto l287
				}
				position++
				if !_rules[ruleNumber]() {
					goto l287
				}
				if buffer[position] != rune('-') {
					goto l287
				}
				position++
				if !_rules[ruleNumber]() {
					goto l287
				}
				add(ruleRFC3339NanoDate, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 45 RFC3339NanoTime <- <(Number ':' Number ':' Number ('.' Number)?)> */
		func() bool {
			position289, tokenIndex289 := position, tokenIndex
			{
				position290 := position
				if !_rules[ruleNumber]() {
					goto l289
				}
				if buffer[position] != rune(':') {
					goto l289
				}
				position++
				if !_rules[ruleNumber]() {
					goto l289
				}
				if buffer[position] != rune(':') {
					goto l289
				}
				position++
				if !_rules[ruleNumber]() {
					goto l289
				}
				{
					position291, tokenIndex291 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l291
					}
					position++
					if !_rules[ruleNumber]() {
						goto l291
					}
					goto l292
				l291:
					position, tokenIndex = position291, tokenIndex291
				}
			l292:
				add(ruleRFC3339NanoTime, position290)
			}
			return true
		l289:
			position, tokenIndex = position289, tokenIndex289
			return false
		},
		/* 46 RFC3339NanoTimezone <- <('Z' / ('+' Number ':' Number))> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				{
					position295, tokenIndex295 := position, tokenIndex
					if buffer[position] != rune('Z') {
						goto l296
					}
					position++
					goto l295
				l296:
					position, tokenIndex = position295, tokenIndex295
					if buffer[position] != rune('+') {
						goto l293
					}
					position++
					if !_rules[ruleNumber]() {
						goto l293
					}
					if buffer[position] != rune(':') {
						goto l293
					}
					position++
					if !_rules[ruleNumber]() {
						goto l293
					}
				}
			l295:
				add(ruleRFC3339NanoTimezone, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 47 Number <- <<[0-9]+>> */
		func() bool {
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				{
					position299 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l297
					}
					position++
				l300:
					{
						position301, tokenIndex301 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l301
						}
						position++
						goto l300
					l301:
						position, tokenIndex = position301, tokenIndex301
					}
					add(rulePegText, position299)
				}
				add(ruleNumber, position298)
			}
			return true
		l297:
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 48 NOT <- <('!' Space)> */
		func() bool {
			position302, tokenIndex302 := position, tokenIndex
			{
				position303 := position
				if buffer[position] != rune('!') {
					goto l302
				}
				position++
				if !_rules[ruleSpace]() {
					goto l302
				}
				add(ruleNOT, position303)
			}
			return true
		l302:
			position, tokenIndex = position302, tokenIndex302
			return false
		},
		/* 49 NEG <- <('-' Space)> */
		func() bool {
			position304, tokenIndex304 := position, tokenIndex
			{
				position305 := position
				if buffer[position] != rune('-') {
					goto l304
				}
				position++
				if !_rules[ruleSpace]() {
					goto l304
				}
				add(ruleNEG, position305)
			}
			return true
		l304:
			position, tokenIndex = position304, tokenIndex304
			return false
		},
		/* 50 NUM_ADD <- <('+' Space)> */
		func() bool {
			position306, tokenIndex306 := position, tokenIndex
			{
				position307 := position
				if buffer[position] != rune('+') {
					goto l306
				}
				position++
				if !_rules[ruleSpace]() {
					goto l306
				}
				add(ruleNUM_ADD, position307)
			}
			return true
		l306:
			position, tokenIndex = position306, tokenIndex306
			return false
		},
		/* 51 NUM_SUB <- <('-' Space)> */
		func() bool {
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				if buffer[position] != rune('-') {
					goto l308
				}
				position++
				if !_rules[ruleSpace]() {
					goto l308
				}
				add(ruleNUM_SUB, position309)
			}
			return true
		l308:
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 52 NUM_DIV <- <('/' Space)> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if buffer[position] != rune('/') {
					goto l310
				}
				position++
				if !_rules[ruleSpace]() {
					goto l310
				}
				add(ruleNUM_DIV, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 53 NUM_MUL <- <('*' Space)> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if buffer[position] != rune('*') {
					goto l312
				}
				position++
				if !_rules[ruleSpace]() {
					goto l312
				}
				add(ruleNUM_MUL, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 54 LOG_AND <- <('&' '&' Space)> */
		func() bool {
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				if buffer[position] != rune('&') {
					goto l314
				}
				position++
				if buffer[position] != rune('&') {
					goto l314
				}
				position++
				if !_rules[ruleSpace]() {
					goto l314
				}
				add(ruleLOG_AND, position315)
			}
			return true
		l314:
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 55 LOG_OR <- <('|' '|' Space)> */
		func() bool {
			position316, tokenIndex316 := position, tokenIndex
			{
				position317 := position
				if buffer[position] != rune('|') {
					goto l316
				}
				position++
				if buffer[position] != rune('|') {
					goto l316
				}
				position++
				if !_rules[ruleSpace]() {
					goto l316
				}
				add(ruleLOG_OR, position317)
			}
			return true
		l316:
			position, tokenIndex = position316, tokenIndex316
			return false
		},
		/* 56 CMP_EQ <- <('=' '=' Space)> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if buffer[position] != rune('=') {
					goto l318
				}
				position++
				if buffer[position] != rune('=') {
					goto l318
				}
				position++
				if !_rules[ruleSpace]() {
					goto l318
				}
				add(ruleCMP_EQ, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 57 CMP_NOTEQ <- <('!' '=' Space)> */
		func() bool {
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				if buffer[position] != rune('!') {
					goto l320
				}
				position++
				if buffer[position] != rune('=') {
					goto l320
				}
				position++
				if !_rules[ruleSpace]() {
					goto l320
				}
				add(ruleCMP_NOTEQ, position321)
			}
			return true
		l320:
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 58 CMP_GT <- <('>' Space)> */
		func() bool {
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				if buffer[position] != rune('>') {
					goto l322
				}
				position++
				if !_rules[ruleSpace]() {
					goto l322
				}
				add(ruleCMP_GT, position323)
			}
			return true
		l322:
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 59 CMP_GTE <- <('>' '=' Space)> */
		func() bool {
			position324, tokenIndex324 := position, tokenIndex
			{
				position325 := position
				if buffer[position] != rune('>') {
					goto l324
				}
				position++
				if buffer[position] != rune('=') {
					goto l324
				}
				position++
				if !_rules[ruleSpace]() {
					goto l324
				}
				add(ruleCMP_GTE, position325)
			}
			return true
		l324:
			position, tokenIndex = position324, tokenIndex324
			return false
		},
		/* 60 CMP_LT <- <('<' Space)> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				if buffer[position] != rune('<') {
					goto l326
				}
				position++
				if !_rules[ruleSpace]() {
					goto l326
				}
				add(ruleCMP_LT, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 61 CMP_LTE <- <('<' '=' Space)> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != rune('<') {
					goto l328
				}
				position++
				if buffer[position] != rune('=') {
					goto l328
				}
				position++
				if !_rules[ruleSpace]() {
					goto l328
				}
				add(ruleCMP_LTE, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 62 SET_IN <- <('i' 'n' Space)> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				if buffer[position] != rune('i') {
					goto l330
				}
				position++
				if buffer[position] != rune('n') {
					goto l330
				}
				position++
				if !_rules[ruleSpace]() {
					goto l330
				}
				add(ruleSET_IN, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 63 SET_NOTIN <- <('n' 'o' 't' ' ' 'i' 'n' Space)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if buffer[position] != rune('n') {
					goto l332
				}
				position++
				if buffer[position] != rune('o') {
					goto l332
				}
				position++
				if buffer[position] != rune('t') {
					goto l332
				}
				position++
				if buffer[position] != rune(' ') {
					goto l332
				}
				position++
				if buffer[position] != rune('i') {
					goto l332
				}
				position++
				if buffer[position] != rune('n') {
					goto l332
				}
				position++
				if !_rules[ruleSpace]() {
					goto l332
				}
				add(ruleSET_NOTIN, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 64 PIPE <- <('|' Space)> */
		func() bool {
			position334, tokenIndex334 := position, tokenIndex
			{
				position335 := position
				if buffer[position] != rune('|') {
					goto l334
				}
				position++
				if !_rules[ruleSpace]() {
					goto l334
				}
				add(rulePIPE, position335)
			}
			return true
		l334:
			position, tokenIndex = position334, tokenIndex334
			return false
		},
		/* 65 DOT <- <('.' Space)> */
		func() bool {
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
				if buffer[position] != rune('.') {
					goto l336
				}
				position++
				if !_rules[ruleSpace]() {
					goto l336
				}
				add(ruleDOT, position337)
			}
			return true
		l336:
			position, tokenIndex = position336, tokenIndex336
			return false
		},
		/* 66 L_PARENS <- <('(' Space)> */
		func() bool {
			position338, tokenIndex338 := position, tokenIndex
			{
				position339 := position
				if buffer[position] != rune('(') {
					goto l338
				}
				position++
				if !_rules[ruleSpace]() {
					goto l338
				}
				add(ruleL_PARENS, position339)
			}
			return true
		l338:
			position, tokenIndex = position338, tokenIndex338
			return false
		},
		/* 67 R_PARENS <- <(')' Space)> */
		func() bool {
			position340, tokenIndex340 := position, tokenIndex
			{
				position341 := position
				if buffer[position] != rune(')') {
					goto l340
				}
				position++
				if !_rules[ruleSpace]() {
					goto l340
				}
				add(ruleR_PARENS, position341)
			}
			return true
		l340:
			position, tokenIndex = position340, tokenIndex340
			return false
		},
		/* 68 L_BRACKET <- <('[' Space)> */
		func() bool {
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				if buffer[position] != rune('[') {
					goto l342
				}
				position++
				if !_rules[ruleSpace]() {
					goto l342
				}
				add(ruleL_BRACKET, position343)
			}
			return true
		l342:
			position, tokenIndex = position342, tokenIndex342
			return false
		},
		/* 69 R_BRACKET <- <(']' Space)> */
		func() bool {
			position344, tokenIndex344 := position, tokenIndex
			{
				position345 := position
				if buffer[position] != rune(']') {
					goto l344
				}
				position++
				if !_rules[ruleSpace]() {
					goto l344
				}
				add(ruleR_BRACKET, position345)
			}
			return true
		l344:
			position, tokenIndex = position344, tokenIndex344
			return false
		},
		/* 70 L_SQUIGGLY <- <('{' Space)> */
		func() bool {
			position346, tokenIndex346 := position, tokenIndex
			{
				position347 := position
				if buffer[position] != rune('{') {
					goto l346
				}
				position++
				if !_rules[ruleSpace]() {
					goto l346
				}
				add(ruleL_SQUIGGLY, position347)
			}
			return true
		l346:
			position, tokenIndex = position346, tokenIndex346
			return false
		},
		/* 71 R_SQUIGGLY <- <'}'> */
		func() bool {
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				if buffer[position] != rune('}') {
					goto l348
				}
				position++
				add(ruleR_SQUIGGLY, position349)
			}
			return true
		l348:
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 72 COLON <- <(':' Space)> */
		func() bool {
			position350, tokenIndex350 := position, tokenIndex
			{
				position351 := position
				if buffer[position] != rune(':') {
					goto l350
				}
				position++
				if !_rules[ruleSpace]() {
					goto l350
				}
				add(ruleCOLON, position351)
			}
			return true
		l350:
			position, tokenIndex = position350, tokenIndex350
			return false
		},
		/* 73 COMMA <- <(',' Space)> */
		func() bool {
			position352, tokenIndex352 := position, tokenIndex
			{
				position353 := position
				if buffer[position] != rune(',') {
					goto l352
				}
				position++
				if !_rules[ruleSpace]() {
					goto l352
				}
				add(ruleCOMMA, position353)
			}
			return true
		l352:
			position, tokenIndex = position352, tokenIndex352
			return false
		},
		/* 74 Space <- <Whitespace*> */
		func() bool {
			{
				position355 := position
			l356:
				{
					position357, tokenIndex357 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l357
					}
					goto l356
				l357:
					position, tokenIndex = position357, tokenIndex357
				}
				add(ruleSpace, position355)
			}
			return true
		},
		/* 75 MustSpace <- <Whitespace+> */
		func() bool {
			position358, tokenIndex358 := position, tokenIndex
			{
				position359 := position
				if !_rules[ruleWhitespace]() {
					goto l358
				}
			l360:
				{
					position361, tokenIndex361 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l361
					}
					goto l360
				l361:
					position, tokenIndex = position361, tokenIndex361
				}
				add(ruleMustSpace, position359)
			}
			return true
		l358:
			position, tokenIndex = position358, tokenIndex358
			return false
		},
		/* 76 Whitespace <- <(' ' / '\t' / EOL)> */
		func() bool {
			position362, tokenIndex362 := position, tokenIndex
			{
				position363 := position
				{
					position364, tokenIndex364 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l365
					}
					position++
					goto l364
				l365:
					position, tokenIndex = position364, tokenIndex364
					if buffer[position] != rune('\t') {
						goto l366
					}
					position++
					goto l364
				l366:
					position, tokenIndex = position364, tokenIndex364
					if !_rules[ruleEOL]() {
						goto l362
					}
				}
			l364:
				add(ruleWhitespace, position363)
			}
			return true
		l362:
			position, tokenIndex = position362, tokenIndex362
			return false
		},
		/* 77 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position367, tokenIndex367 := position, tokenIndex
			{
				position368 := position
				{
					position369, tokenIndex369 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l370
					}
					position++
					if buffer[position] != rune('\n') {
						goto l370
					}
					position++
					goto l369
				l370:
					position, tokenIndex = position369, tokenIndex369
					if buffer[position] != rune('\n') {
						goto l371
					}
					position++
					goto l369
				l371:
					position, tokenIndex = position369, tokenIndex369
					if buffer[position] != rune('\r') {
						goto l367
					}
					position++
				}
			l369:
				add(ruleEOL, position368)
			}
			return true
		l367:
			position, tokenIndex = position367, tokenIndex367
			return false
		},
		/* 78 EOF <- <!.> */
		func() bool {
			position372, tokenIndex372 := position, tokenIndex
			{
				position373 := position
				{
					position374, tokenIndex374 := position, tokenIndex
					if !matchDot() {
						goto l374
					}
					goto l372
				l374:
					position, tokenIndex = position374, tokenIndex374
				}
				add(ruleEOF, position373)
			}
			return true
		l372:
			position, tokenIndex = position372, tokenIndex372
			return false
		},
		/* 80 Action0 <- <{ p.SetQuery(p.Stmts) }> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		/* 81 Action1 <- <{ p.SetQuery(p.Stmts) }> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 82 Action2 <- <{ p.SetFrom(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 83 Action3 <- <{ p.SetTo(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 84 Action4 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 85 Action5 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 86 Action6 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 87 Action7 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 88 Action8 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 89 Action9 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 90 Action10 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 91 Action11 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 92 Action12 <- <{ p.addFilterStatement(p.FilterOp) }> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 93 Action13 <- <{ p.addSummarizeStatement(p.SummarizeOp) }> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 94 Action14 <- <{ p.addProjectStatement(p.ProjectOp) }> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 95 Action15 <- <{ p.setFilterOp(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 96 Action16 <- <{ p.startSummarizeOp(p.popFunc()) }> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 97 Action17 <- <{ p.addSummarizeByOp(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 98 Action18 <- <{ p.startProjectOp() }> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 99 Action19 <- <{ p.startProjectOpArg(text) }> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 100 Action20 <- <{ p.setProjectOpArgValue(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 101 Action21 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs)) }> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 102 Action22 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs)) }> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 103 Action23 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs)) }> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 104 Action24 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs)) }> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 105 Action25 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs)) }> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 106 Action26 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs)) }> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 107 Action27 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 108 Action28 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 109 Action29 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs)) }> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 110 Action30 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 111 Action31 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs)) }> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 112 Action32 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 113 Action33 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs)) }> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 114 Action34 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs)) }> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 115 Action35 <- <{ index, x := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprIndexor(x, index)) }> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		nil,
		/* 117 Action36 <- <{ selector, x := text, p.popExpr(); p.pushExpr(typesv1.ExprSelector(x, selector)) }> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 118 Action37 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 119 Action38 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg)) }> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 120 Action39 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 121 Action40 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg)) }> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 122 Action41 <- <{ p.pushExpr(typesv1.ExprLiteral(p.Literal)); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 123 Action42 <- <{ fn := p.popFunc(); p.pushExpr(typesv1.ExprFuncCall(fn.Name, fn.Args...)) }> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 124 Action43 <- <{ p.Literal = typesv1.ValStr(p.String) }> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 125 Action44 <- <{ p.Literal = typesv1.ValDuration(p.Duration) }> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 126 Action45 <- <{ p.Literal = typesv1.ValTime(p.Timestamp) }> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
		/* 127 Action46 <- <{ p.Literal = typesv1.ValF64(p.F64) }> */
		func() bool {
			{
				add(ruleAction46, position)
			}
			return true
		},
		/* 128 Action47 <- <{ p.Literal = typesv1.ValI64(p.I64) }> */
		func() bool {
			{
				add(ruleAction47, position)
			}
			return true
		},
		/* 129 Action48 <- <{ p.Literal = typesv1.ValBool(p.Bool) }> */
		func() bool {
			{
				add(ruleAction48, position)
			}
			return true
		},
		/* 130 Action49 <- <{ p.Literal = typesv1.ValArr(p.popArray()...) }> */
		func() bool {
			{
				add(ruleAction49, position)
			}
			return true
		},
		/* 131 Action50 <- <{ p.Literal = typesv1.ValObj(p.popObj()...) }> */
		func() bool {
			{
				add(ruleAction50, position)
			}
			return true
		},
		/* 132 Action51 <- <{ p.pushFunc() }> */
		func() bool {
			{
				add(ruleAction51, position)
			}
			return true
		},
		/* 133 Action52 <- <{ p.setFuncName(text) }> */
		func() bool {
			{
				add(ruleAction52, position)
			}
			return true
		},
		/* 134 Action53 <- <{ p.addFuncArg(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction53, position)
			}
			return true
		},
		/* 135 Action54 <- <{ p.pushExpr(typesv1.ExprIdentifier(text)) }> */
		func() bool {
			{
				add(ruleAction54, position)
			}
			return true
		},
		/* 136 Action55 <- <{ p.String = p.parseString(text) }> */
		func() bool {
			{
				add(ruleAction55, position)
			}
			return true
		},
		/* 137 Action56 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction56, position)
			}
			return true
		},
		/* 138 Action57 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction57, position)
			}
			return true
		},
		/* 139 Action58 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction58, position)
			}
			return true
		},
		/* 140 Action59 <- <{ p.I64 = 0 }> */
		func() bool {
			{
				add(ruleAction59, position)
			}
			return true
		},
		/* 141 Action60 <- <{ p.I64 = p.parseInt64(text) }> */
		func() bool {
			{
				add(ruleAction60, position)
			}
			return true
		},
		/* 142 Action61 <- <{ p.Bool = true }> */
		func() bool {
			{
				add(ruleAction61, position)
			}
			return true
		},
		/* 143 Action62 <- <{ p.Bool = false }> */
		func() bool {
			{
				add(ruleAction62, position)
			}
			return true
		},
		/* 144 Action63 <- <{ p.pushArray() }> */
		func() bool {
			{
				add(ruleAction63, position)
			}
			return true
		},
		/* 145 Action64 <- <{ p.addArrItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction64, position)
			}
			return true
		},
		/* 146 Action65 <- <{ p.pushObj() }> */
		func() bool {
			{
				add(ruleAction65, position)
			}
			return true
		},
		/* 147 Action66 <- <{ p.closeObjItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction66, position)
			}
			return true
		},
		/* 148 Action67 <- <{ p.startObjItem(p.String) }> */
		func() bool {
			{
				add(ruleAction67, position)
			}
			return true
		},
		/* 149 Action68 <- <{ p.Duration = p.parseDurationF64(p.F64, text) }> */
		func() bool {
			{
				add(ruleAction68, position)
			}
			return true
		},
		/* 150 Action69 <- <{ p.Duration = p.parseDurationI64(p.I64, text) }> */
		func() bool {
			{
				add(ruleAction69, position)
			}
			return true
		},
		/* 151 Action70 <- <{ p.Timestamp = p.parseTime(time.RFC3339Nano, text) }> */
		func() bool {
			{
				add(ruleAction70, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
