package logql

// Code generated by peg /Users/antoine/code/src/github.com/humanlogio/api/go/pkg/logql/grammar.peg DO NOT EDIT.

import (
	"fmt"
	"github.com/humanlogio/api/go/types/v1"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleQueryContext
	ruleQueryContextItem
	ruleQueryFrom
	ruleQueryTo
	ruleQueryMachineContext
	ruleQuerySessionContext
	ruleExpr
	ruleExpr1
	ruleExpr2
	ruleExpr3
	ruleExpr4
	ruleExpr5
	ruleLiteral
	ruleFuncCall
	ruleFuncName
	ruleFuncArgs
	ruleFuncArg
	ruleIdentifier
	ruleString
	ruleSelectorId
	ruleF64
	ruleI64
	ruleBool
	ruleReservedKeyword
	ruleArray
	ruleArrayItem
	ruleObject
	ruleObjectItem
	ruleObjectKey
	ruleDuration
	ruleTimestamp
	ruleStringChar
	ruleExponent
	ruleDigits
	ruleRFC3339Nano
	ruleRFC3339NanoDate
	ruleRFC3339NanoTime
	ruleRFC3339NanoTimezone
	ruleNumber
	ruleNOT
	ruleNEG
	ruleNUM_ADD
	ruleNUM_SUB
	ruleNUM_DIV
	ruleNUM_MUL
	ruleLOG_AND
	ruleLOG_OR
	ruleCMP_EQ
	ruleCMP_NOTEQ
	ruleCMP_GT
	ruleCMP_GTE
	ruleCMP_LT
	ruleCMP_LTE
	ruleSET_IN
	ruleSET_NOTIN
	rulePIPE
	ruleDOT
	ruleL_PARENS
	ruleR_PARENS
	ruleL_BRACKET
	ruleR_BRACKET
	ruleL_SQUIGGLY
	ruleR_SQUIGGLY
	ruleCOLON
	ruleCOMMA
	ruleSpace
	ruleMustSpace
	ruleWhitespace
	ruleEOL
	ruleEOF
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	rulePegText
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"QueryContext",
	"QueryContextItem",
	"QueryFrom",
	"QueryTo",
	"QueryMachineContext",
	"QuerySessionContext",
	"Expr",
	"Expr1",
	"Expr2",
	"Expr3",
	"Expr4",
	"Expr5",
	"Literal",
	"FuncCall",
	"FuncName",
	"FuncArgs",
	"FuncArg",
	"Identifier",
	"String",
	"SelectorId",
	"F64",
	"I64",
	"Bool",
	"ReservedKeyword",
	"Array",
	"ArrayItem",
	"Object",
	"ObjectItem",
	"ObjectKey",
	"Duration",
	"Timestamp",
	"StringChar",
	"Exponent",
	"Digits",
	"RFC3339Nano",
	"RFC3339NanoDate",
	"RFC3339NanoTime",
	"RFC3339NanoTimezone",
	"Number",
	"NOT",
	"NEG",
	"NUM_ADD",
	"NUM_SUB",
	"NUM_DIV",
	"NUM_MUL",
	"LOG_AND",
	"LOG_OR",
	"CMP_EQ",
	"CMP_NOTEQ",
	"CMP_GT",
	"CMP_GTE",
	"CMP_LT",
	"CMP_LTE",
	"SET_IN",
	"SET_NOTIN",
	"PIPE",
	"DOT",
	"L_PARENS",
	"R_PARENS",
	"L_BRACKET",
	"R_BRACKET",
	"L_SQUIGGLY",
	"R_SQUIGGLY",
	"COLON",
	"COMMA",
	"Space",
	"MustSpace",
	"Whitespace",
	"EOL",
	"EOF",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"PegText",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type logQL struct {

	// the query being built
	LogQuery *typesv1.LogQuery

	// stack for recursive generic structures
	Exprs []*typesv1.Expr

	// scratch space, not needed but `Literal` being a type is convenient
	Literal *typesv1.Val

	// scalars
	String    string
	F64       float64
	I64       int64
	Bool      bool
	Timestamp time.Time
	Duration  time.Duration

	// stack for non-expr recursive structures
	Arrs      [][]*typesv1.Val
	ObjsKVs   [][]*typesv1.KV
	FuncCalls []*typesv1.FuncCall

	// errors seen along the way
	err error

	Buffer string
	buffer []rune
	rules  [138]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *logQL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *logQL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *logQL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *logQL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *logQL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *logQL) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *logQL) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.SetQuery(p.popExpr())
		case ruleAction1:
			p.SetQuery(p.popExpr())
		case ruleAction2:
			p.SetFrom(p.Timestamp)
		case ruleAction3:
			p.SetTo(p.Timestamp)
		case ruleAction4:
			p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction5:
			p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction6:
			p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction7:
			p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction8:
			p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction9:
			p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction10:
			p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction11:
			p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction12:
			tail, head := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprPipe(head, tail))
		case ruleAction13:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs))
		case ruleAction14:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs))
		case ruleAction15:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs))
		case ruleAction16:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs))
		case ruleAction17:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs))
		case ruleAction18:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs))
		case ruleAction19:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs))
		case ruleAction20:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs))
		case ruleAction21:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs))
		case ruleAction22:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs))
		case ruleAction23:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs))
		case ruleAction24:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs))
		case ruleAction25:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs))
		case ruleAction26:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs))
		case ruleAction27:
			index, x := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprIndexor(x, index))
		case ruleAction28:
			selector, x := text, p.popExpr()
			p.pushExpr(typesv1.ExprSelector(x, selector))
		case ruleAction29:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction30:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg))
		case ruleAction31:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction32:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg))
		case ruleAction33:
			p.pushExpr(typesv1.ExprLiteral(p.Literal))
			p.Literal = nil
		case ruleAction34:
			p.Literal = typesv1.ValStr(p.String)
		case ruleAction35:
			p.Literal = typesv1.ValDuration(p.Duration)
		case ruleAction36:
			p.Literal = typesv1.ValTime(p.Timestamp)
		case ruleAction37:
			p.Literal = typesv1.ValF64(p.F64)
		case ruleAction38:
			p.Literal = typesv1.ValI64(p.I64)
		case ruleAction39:
			p.Literal = typesv1.ValBool(p.Bool)
		case ruleAction40:
			p.Literal = typesv1.ValArr(p.popArray()...)
		case ruleAction41:
			p.Literal = typesv1.ValObj(p.popObj()...)
		case ruleAction42:
			p.pushFunc()
		case ruleAction43:
			p.pushExpr(p.popFunc())
		case ruleAction44:
			p.setFuncName(text)
		case ruleAction45:
			p.addFuncArg(p.popExpr())
		case ruleAction46:
			p.pushExpr(typesv1.ExprIdentifier("lvl"))
		case ruleAction47:
			p.pushExpr(typesv1.ExprIdentifier("msg"))
		case ruleAction48:
			p.pushExpr(typesv1.ExprIdentifier("kv"))
		case ruleAction49:
			p.String = p.parseString(text)
		case ruleAction50:
			p.F64 = p.parseFloat64(text)
		case ruleAction51:
			p.F64 = p.parseFloat64(text)
		case ruleAction52:
			p.F64 = p.parseFloat64(text)
		case ruleAction53:
			p.I64 = 0
		case ruleAction54:
			p.I64 = p.parseInt64(text)
		case ruleAction55:
			p.Bool = true
		case ruleAction56:
			p.Bool = false
		case ruleAction57:
			p.pushArray()
		case ruleAction58:
			p.addArrItem(p.Literal)
			p.Literal = nil
		case ruleAction59:
			p.pushObj()
		case ruleAction60:
			p.closeObjItem(p.Literal)
			p.Literal = nil
		case ruleAction61:
			p.startObjItem(p.String)
		case ruleAction62:
			p.Duration = p.parseDurationF64(p.F64, text)
		case ruleAction63:
			p.Duration = p.parseDurationI64(p.I64, text)
		case ruleAction64:
			p.Timestamp = p.parseTime(time.RFC3339Nano, text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*logQL) error {
	return func(p *logQL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*logQL) error {
	return func(p *logQL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *logQL) Init(options ...func(*logQL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Space ((Expr Action0) / ((QueryContext MustSpace)? Expr Action1) / QueryContext)? EOF)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpace]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleExpr]() {
							goto l5
						}
						if !_rules[ruleAction0]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						{
							position7, tokenIndex7 := position, tokenIndex
							if !_rules[ruleQueryContext]() {
								goto l7
							}
							if !_rules[ruleMustSpace]() {
								goto l7
							}
							goto l8
						l7:
							position, tokenIndex = position7, tokenIndex7
						}
					l8:
						if !_rules[ruleExpr]() {
							goto l6
						}
						if !_rules[ruleAction1]() {
							goto l6
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleQueryContext]() {
							goto l2
						}
					}
				l4:
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
				if !_rules[ruleEOF]() {
					goto l0
				}
				add(ruleGrammar, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 QueryContext <- <(L_SQUIGGLY Space QueryContextItem+ R_SQUIGGLY)> */
		func() bool {
			position9, tokenIndex9 := position, tokenIndex
			{
				position10 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l9
				}
				if !_rules[ruleSpace]() {
					goto l9
				}
				if !_rules[ruleQueryContextItem]() {
					goto l9
				}
			l11:
				{
					position12, tokenIndex12 := position, tokenIndex
					if !_rules[ruleQueryContextItem]() {
						goto l12
					}
					goto l11
				l12:
					position, tokenIndex = position12, tokenIndex12
				}
				if !_rules[ruleR_SQUIGGLY]() {
					goto l9
				}
				add(ruleQueryContext, position10)
			}
			return true
		l9:
			position, tokenIndex = position9, tokenIndex9
			return false
		},
		/* 2 QueryContextItem <- <((QueryMachineContext / QuerySessionContext / QueryFrom / QueryTo) Space)> */
		func() bool {
			position13, tokenIndex13 := position, tokenIndex
			{
				position14 := position
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleQueryMachineContext]() {
						goto l16
					}
					goto l15
				l16:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQuerySessionContext]() {
						goto l17
					}
					goto l15
				l17:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQueryFrom]() {
						goto l18
					}
					goto l15
				l18:
					position, tokenIndex = position15, tokenIndex15
					if !_rules[ruleQueryTo]() {
						goto l13
					}
				}
			l15:
				if !_rules[ruleSpace]() {
					goto l13
				}
				add(ruleQueryContextItem, position14)
			}
			return true
		l13:
			position, tokenIndex = position13, tokenIndex13
			return false
		},
		/* 3 QueryFrom <- <('f' 'r' 'o' 'm' Space CMP_EQ Space Timestamp Action2)> */
		func() bool {
			position19, tokenIndex19 := position, tokenIndex
			{
				position20 := position
				if buffer[position] != rune('f') {
					goto l19
				}
				position++
				if buffer[position] != rune('r') {
					goto l19
				}
				position++
				if buffer[position] != rune('o') {
					goto l19
				}
				position++
				if buffer[position] != rune('m') {
					goto l19
				}
				position++
				if !_rules[ruleSpace]() {
					goto l19
				}
				if !_rules[ruleCMP_EQ]() {
					goto l19
				}
				if !_rules[ruleSpace]() {
					goto l19
				}
				if !_rules[ruleTimestamp]() {
					goto l19
				}
				if !_rules[ruleAction2]() {
					goto l19
				}
				add(ruleQueryFrom, position20)
			}
			return true
		l19:
			position, tokenIndex = position19, tokenIndex19
			return false
		},
		/* 4 QueryTo <- <('t' 'o' Space CMP_EQ Space Timestamp Action3)> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if buffer[position] != rune('t') {
					goto l21
				}
				position++
				if buffer[position] != rune('o') {
					goto l21
				}
				position++
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleCMP_EQ]() {
					goto l21
				}
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleTimestamp]() {
					goto l21
				}
				if !_rules[ruleAction3]() {
					goto l21
				}
				add(ruleQueryTo, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 5 QueryMachineContext <- <('m' 'a' 'c' 'h' 'i' 'n' 'e' Space ((CMP_EQ Space Expr Action4) / (CMP_NOTEQ Space Expr Action5) / (SET_IN Space Expr Action6) / (SET_NOTIN Space Expr Action7)))> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if buffer[position] != rune('m') {
					goto l23
				}
				position++
				if buffer[position] != rune('a') {
					goto l23
				}
				position++
				if buffer[position] != rune('c') {
					goto l23
				}
				position++
				if buffer[position] != rune('h') {
					goto l23
				}
				position++
				if buffer[position] != rune('i') {
					goto l23
				}
				position++
				if buffer[position] != rune('n') {
					goto l23
				}
				position++
				if buffer[position] != rune('e') {
					goto l23
				}
				position++
				if !_rules[ruleSpace]() {
					goto l23
				}
				{
					position25, tokenIndex25 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l26
					}
					if !_rules[ruleSpace]() {
						goto l26
					}
					if !_rules[ruleExpr]() {
						goto l26
					}
					if !_rules[ruleAction4]() {
						goto l26
					}
					goto l25
				l26:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleCMP_NOTEQ]() {
						goto l27
					}
					if !_rules[ruleSpace]() {
						goto l27
					}
					if !_rules[ruleExpr]() {
						goto l27
					}
					if !_rules[ruleAction5]() {
						goto l27
					}
					goto l25
				l27:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleSET_IN]() {
						goto l28
					}
					if !_rules[ruleSpace]() {
						goto l28
					}
					if !_rules[ruleExpr]() {
						goto l28
					}
					if !_rules[ruleAction6]() {
						goto l28
					}
					goto l25
				l28:
					position, tokenIndex = position25, tokenIndex25
					if !_rules[ruleSET_NOTIN]() {
						goto l23
					}
					if !_rules[ruleSpace]() {
						goto l23
					}
					if !_rules[ruleExpr]() {
						goto l23
					}
					if !_rules[ruleAction7]() {
						goto l23
					}
				}
			l25:
				add(ruleQueryMachineContext, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 6 QuerySessionContext <- <('s' 'e' 's' 's' 'i' 'o' 'n' Space ((CMP_EQ Space Expr Action8) / (CMP_NOTEQ Space Expr Action9) / (SET_IN Space Expr Action10) / (SET_NOTIN Space Expr Action11)))> */
		func() bool {
			position29, tokenIndex29 := position, tokenIndex
			{
				position30 := position
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('e') {
					goto l29
				}
				position++
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('s') {
					goto l29
				}
				position++
				if buffer[position] != rune('i') {
					goto l29
				}
				position++
				if buffer[position] != rune('o') {
					goto l29
				}
				position++
				if buffer[position] != rune('n') {
					goto l29
				}
				position++
				if !_rules[ruleSpace]() {
					goto l29
				}
				{
					position31, tokenIndex31 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l32
					}
					if !_rules[ruleSpace]() {
						goto l32
					}
					if !_rules[ruleExpr]() {
						goto l32
					}
					if !_rules[ruleAction8]() {
						goto l32
					}
					goto l31
				l32:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleCMP_NOTEQ]() {
						goto l33
					}
					if !_rules[ruleSpace]() {
						goto l33
					}
					if !_rules[ruleExpr]() {
						goto l33
					}
					if !_rules[ruleAction9]() {
						goto l33
					}
					goto l31
				l33:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleSET_IN]() {
						goto l34
					}
					if !_rules[ruleSpace]() {
						goto l34
					}
					if !_rules[ruleExpr]() {
						goto l34
					}
					if !_rules[ruleAction10]() {
						goto l34
					}
					goto l31
				l34:
					position, tokenIndex = position31, tokenIndex31
					if !_rules[ruleSET_NOTIN]() {
						goto l29
					}
					if !_rules[ruleSpace]() {
						goto l29
					}
					if !_rules[ruleExpr]() {
						goto l29
					}
					if !_rules[ruleAction11]() {
						goto l29
					}
				}
			l31:
				add(ruleQuerySessionContext, position30)
			}
			return true
		l29:
			position, tokenIndex = position29, tokenIndex29
			return false
		},
		/* 7 Expr <- <(Expr1 ((Space PIPE Space Expr1 Action12) / (Space NUM_ADD Expr1 Space Action13) / (Space NUM_SUB Expr1 Space Action14))*)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleExpr1]() {
					goto l35
				}
			l37:
				{
					position38, tokenIndex38 := position, tokenIndex
					{
						position39, tokenIndex39 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l40
						}
						if !_rules[rulePIPE]() {
							goto l40
						}
						if !_rules[ruleSpace]() {
							goto l40
						}
						if !_rules[ruleExpr1]() {
							goto l40
						}
						if !_rules[ruleAction12]() {
							goto l40
						}
						goto l39
					l40:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleSpace]() {
							goto l41
						}
						if !_rules[ruleNUM_ADD]() {
							goto l41
						}
						if !_rules[ruleExpr1]() {
							goto l41
						}
						if !_rules[ruleSpace]() {
							goto l41
						}
						if !_rules[ruleAction13]() {
							goto l41
						}
						goto l39
					l41:
						position, tokenIndex = position39, tokenIndex39
						if !_rules[ruleSpace]() {
							goto l38
						}
						if !_rules[ruleNUM_SUB]() {
							goto l38
						}
						if !_rules[ruleExpr1]() {
							goto l38
						}
						if !_rules[ruleSpace]() {
							goto l38
						}
						if !_rules[ruleAction14]() {
							goto l38
						}
					}
				l39:
					goto l37
				l38:
					position, tokenIndex = position38, tokenIndex38
				}
				add(ruleExpr, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 8 Expr1 <- <(Expr2 ((Space NUM_MUL Expr2 Space Action15) / (Space NUM_DIV Expr2 Space Action16))*)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				if !_rules[ruleExpr2]() {
					goto l42
				}
			l44:
				{
					position45, tokenIndex45 := position, tokenIndex
					{
						position46, tokenIndex46 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l47
						}
						if !_rules[ruleNUM_MUL]() {
							goto l47
						}
						if !_rules[ruleExpr2]() {
							goto l47
						}
						if !_rules[ruleSpace]() {
							goto l47
						}
						if !_rules[ruleAction15]() {
							goto l47
						}
						goto l46
					l47:
						position, tokenIndex = position46, tokenIndex46
						if !_rules[ruleSpace]() {
							goto l45
						}
						if !_rules[ruleNUM_DIV]() {
							goto l45
						}
						if !_rules[ruleExpr2]() {
							goto l45
						}
						if !_rules[ruleSpace]() {
							goto l45
						}
						if !_rules[ruleAction16]() {
							goto l45
						}
					}
				l46:
					goto l44
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
				add(ruleExpr1, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 Expr2 <- <(Expr3 ((Space LOG_AND Expr3 Space Action17) / (Space LOG_OR Expr3 Space Action18))*)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleExpr3]() {
					goto l48
				}
			l50:
				{
					position51, tokenIndex51 := position, tokenIndex
					{
						position52, tokenIndex52 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l53
						}
						if !_rules[ruleLOG_AND]() {
							goto l53
						}
						if !_rules[ruleExpr3]() {
							goto l53
						}
						if !_rules[ruleSpace]() {
							goto l53
						}
						if !_rules[ruleAction17]() {
							goto l53
						}
						goto l52
					l53:
						position, tokenIndex = position52, tokenIndex52
						if !_rules[ruleSpace]() {
							goto l51
						}
						if !_rules[ruleLOG_OR]() {
							goto l51
						}
						if !_rules[ruleExpr3]() {
							goto l51
						}
						if !_rules[ruleSpace]() {
							goto l51
						}
						if !_rules[ruleAction18]() {
							goto l51
						}
					}
				l52:
					goto l50
				l51:
					position, tokenIndex = position51, tokenIndex51
				}
				add(ruleExpr2, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 10 Expr3 <- <(Expr4 ((Space CMP_EQ Expr4 Action19) / (Space CMP_NOTEQ Expr4 Action20) / (Space CMP_GT Expr4 Action21) / (Space CMP_GTE Expr4 Action22) / (Space CMP_LT Expr4 Action23) / (Space CMP_LTE Expr4 Action24) / (Space SET_IN Expr4 Action25) / (Space SET_NOTIN Expr4 Action26))*)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if !_rules[ruleExpr4]() {
					goto l54
				}
			l56:
				{
					position57, tokenIndex57 := position, tokenIndex
					{
						position58, tokenIndex58 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l59
						}
						if !_rules[ruleCMP_EQ]() {
							goto l59
						}
						if !_rules[ruleExpr4]() {
							goto l59
						}
						if !_rules[ruleAction19]() {
							goto l59
						}
						goto l58
					l59:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l60
						}
						if !_rules[ruleCMP_NOTEQ]() {
							goto l60
						}
						if !_rules[ruleExpr4]() {
							goto l60
						}
						if !_rules[ruleAction20]() {
							goto l60
						}
						goto l58
					l60:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l61
						}
						if !_rules[ruleCMP_GT]() {
							goto l61
						}
						if !_rules[ruleExpr4]() {
							goto l61
						}
						if !_rules[ruleAction21]() {
							goto l61
						}
						goto l58
					l61:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l62
						}
						if !_rules[ruleCMP_GTE]() {
							goto l62
						}
						if !_rules[ruleExpr4]() {
							goto l62
						}
						if !_rules[ruleAction22]() {
							goto l62
						}
						goto l58
					l62:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l63
						}
						if !_rules[ruleCMP_LT]() {
							goto l63
						}
						if !_rules[ruleExpr4]() {
							goto l63
						}
						if !_rules[ruleAction23]() {
							goto l63
						}
						goto l58
					l63:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l64
						}
						if !_rules[ruleCMP_LTE]() {
							goto l64
						}
						if !_rules[ruleExpr4]() {
							goto l64
						}
						if !_rules[ruleAction24]() {
							goto l64
						}
						goto l58
					l64:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l65
						}
						if !_rules[ruleSET_IN]() {
							goto l65
						}
						if !_rules[ruleExpr4]() {
							goto l65
						}
						if !_rules[ruleAction25]() {
							goto l65
						}
						goto l58
					l65:
						position, tokenIndex = position58, tokenIndex58
						if !_rules[ruleSpace]() {
							goto l57
						}
						if !_rules[ruleSET_NOTIN]() {
							goto l57
						}
						if !_rules[ruleExpr4]() {
							goto l57
						}
						if !_rules[ruleAction26]() {
							goto l57
						}
					}
				l58:
					goto l56
				l57:
					position, tokenIndex = position57, tokenIndex57
				}
				add(ruleExpr3, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 11 Expr4 <- <(Expr5 ((Space L_BRACKET Expr5 R_BRACKET Action27) / (Space DOT <SelectorId> Action28))*)> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				if !_rules[ruleExpr5]() {
					goto l66
				}
			l68:
				{
					position69, tokenIndex69 := position, tokenIndex
					{
						position70, tokenIndex70 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l71
						}
						if !_rules[ruleL_BRACKET]() {
							goto l71
						}
						if !_rules[ruleExpr5]() {
							goto l71
						}
						if !_rules[ruleR_BRACKET]() {
							goto l71
						}
						if !_rules[ruleAction27]() {
							goto l71
						}
						goto l70
					l71:
						position, tokenIndex = position70, tokenIndex70
						if !_rules[ruleSpace]() {
							goto l69
						}
						if !_rules[ruleDOT]() {
							goto l69
						}
						{
							position72 := position
							if !_rules[ruleSelectorId]() {
								goto l69
							}
							add(rulePegText, position72)
						}
						if !_rules[ruleAction28]() {
							goto l69
						}
					}
				l70:
					goto l68
				l69:
					position, tokenIndex = position69, tokenIndex69
				}
				add(ruleExpr4, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 12 Expr5 <- <((L_PARENS Expr R_PARENS Space) / (NOT Literal Space Action29) / (NOT L_PARENS Expr R_PARENS Space Action30) / (NEG Literal Space Action31) / (NEG L_PARENS Expr R_PARENS Space Action32) / (Literal Space Action33) / (Identifier Space) / (FuncCall Space))> */
		func() bool {
			position73, tokenIndex73 := position, tokenIndex
			{
				position74 := position
				{
					position75, tokenIndex75 := position, tokenIndex
					if !_rules[ruleL_PARENS]() {
						goto l76
					}
					if !_rules[ruleExpr]() {
						goto l76
					}
					if !_rules[ruleR_PARENS]() {
						goto l76
					}
					if !_rules[ruleSpace]() {
						goto l76
					}
					goto l75
				l76:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleNOT]() {
						goto l77
					}
					if !_rules[ruleLiteral]() {
						goto l77
					}
					if !_rules[ruleSpace]() {
						goto l77
					}
					if !_rules[ruleAction29]() {
						goto l77
					}
					goto l75
				l77:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleNOT]() {
						goto l78
					}
					if !_rules[ruleL_PARENS]() {
						goto l78
					}
					if !_rules[ruleExpr]() {
						goto l78
					}
					if !_rules[ruleR_PARENS]() {
						goto l78
					}
					if !_rules[ruleSpace]() {
						goto l78
					}
					if !_rules[ruleAction30]() {
						goto l78
					}
					goto l75
				l78:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleNEG]() {
						goto l79
					}
					if !_rules[ruleLiteral]() {
						goto l79
					}
					if !_rules[ruleSpace]() {
						goto l79
					}
					if !_rules[ruleAction31]() {
						goto l79
					}
					goto l75
				l79:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleNEG]() {
						goto l80
					}
					if !_rules[ruleL_PARENS]() {
						goto l80
					}
					if !_rules[ruleExpr]() {
						goto l80
					}
					if !_rules[ruleR_PARENS]() {
						goto l80
					}
					if !_rules[ruleSpace]() {
						goto l80
					}
					if !_rules[ruleAction32]() {
						goto l80
					}
					goto l75
				l80:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleLiteral]() {
						goto l81
					}
					if !_rules[ruleSpace]() {
						goto l81
					}
					if !_rules[ruleAction33]() {
						goto l81
					}
					goto l75
				l81:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleIdentifier]() {
						goto l82
					}
					if !_rules[ruleSpace]() {
						goto l82
					}
					goto l75
				l82:
					position, tokenIndex = position75, tokenIndex75
					if !_rules[ruleFuncCall]() {
						goto l73
					}
					if !_rules[ruleSpace]() {
						goto l73
					}
				}
			l75:
				add(ruleExpr5, position74)
			}
			return true
		l73:
			position, tokenIndex = position73, tokenIndex73
			return false
		},
		/* 13 Literal <- <((String Action34) / (('d' 'u' 'r' ':')? Duration Action35) / (('t' 's' ':')? Timestamp Action36) / (F64 Action37) / (I64 Action38) / (Bool Action39) / (Array Action40) / (Object Action41))> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				{
					position85, tokenIndex85 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l86
					}
					if !_rules[ruleAction34]() {
						goto l86
					}
					goto l85
				l86:
					position, tokenIndex = position85, tokenIndex85
					{
						position88, tokenIndex88 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l88
						}
						position++
						if buffer[position] != rune('u') {
							goto l88
						}
						position++
						if buffer[position] != rune('r') {
							goto l88
						}
						position++
						if buffer[position] != rune(':') {
							goto l88
						}
						position++
						goto l89
					l88:
						position, tokenIndex = position88, tokenIndex88
					}
				l89:
					if !_rules[ruleDuration]() {
						goto l87
					}
					if !_rules[ruleAction35]() {
						goto l87
					}
					goto l85
				l87:
					position, tokenIndex = position85, tokenIndex85
					{
						position91, tokenIndex91 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l91
						}
						position++
						if buffer[position] != rune('s') {
							goto l91
						}
						position++
						if buffer[position] != rune(':') {
							goto l91
						}
						position++
						goto l92
					l91:
						position, tokenIndex = position91, tokenIndex91
					}
				l92:
					if !_rules[ruleTimestamp]() {
						goto l90
					}
					if !_rules[ruleAction36]() {
						goto l90
					}
					goto l85
				l90:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleF64]() {
						goto l93
					}
					if !_rules[ruleAction37]() {
						goto l93
					}
					goto l85
				l93:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleI64]() {
						goto l94
					}
					if !_rules[ruleAction38]() {
						goto l94
					}
					goto l85
				l94:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleBool]() {
						goto l95
					}
					if !_rules[ruleAction39]() {
						goto l95
					}
					goto l85
				l95:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleArray]() {
						goto l96
					}
					if !_rules[ruleAction40]() {
						goto l96
					}
					goto l85
				l96:
					position, tokenIndex = position85, tokenIndex85
					if !_rules[ruleObject]() {
						goto l83
					}
					if !_rules[ruleAction41]() {
						goto l83
					}
				}
			l85:
				add(ruleLiteral, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 14 FuncCall <- <(Action42 FuncName '(' FuncArgs? ')' Space Action43)> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				if !_rules[ruleAction42]() {
					goto l97
				}
				if !_rules[ruleFuncName]() {
					goto l97
				}
				if buffer[position] != rune('(') {
					goto l97
				}
				position++
				{
					position99, tokenIndex99 := position, tokenIndex
					if !_rules[ruleFuncArgs]() {
						goto l99
					}
					goto l100
				l99:
					position, tokenIndex = position99, tokenIndex99
				}
			l100:
				if buffer[position] != rune(')') {
					goto l97
				}
				position++
				if !_rules[ruleSpace]() {
					goto l97
				}
				if !_rules[ruleAction43]() {
					goto l97
				}
				add(ruleFuncCall, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 15 FuncName <- <(!ReservedKeyword <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / '_' / [0-9])*)> Action44)> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				{
					position103, tokenIndex103 := position, tokenIndex
					if !_rules[ruleReservedKeyword]() {
						goto l103
					}
					goto l101
				l103:
					position, tokenIndex = position103, tokenIndex103
				}
				{
					position104 := position
					{
						position105, tokenIndex105 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l106
						}
						position++
						goto l105
					l106:
						position, tokenIndex = position105, tokenIndex105
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l107
						}
						position++
						goto l105
					l107:
						position, tokenIndex = position105, tokenIndex105
						if buffer[position] != rune('_') {
							goto l101
						}
						position++
					}
				l105:
				l108:
					{
						position109, tokenIndex109 := position, tokenIndex
						{
							position110, tokenIndex110 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l111
							}
							position++
							goto l110
						l111:
							position, tokenIndex = position110, tokenIndex110
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l112
							}
							position++
							goto l110
						l112:
							position, tokenIndex = position110, tokenIndex110
							if buffer[position] != rune('_') {
								goto l113
							}
							position++
							goto l110
						l113:
							position, tokenIndex = position110, tokenIndex110
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l109
							}
							position++
						}
					l110:
						goto l108
					l109:
						position, tokenIndex = position109, tokenIndex109
					}
					add(rulePegText, position104)
				}
				if !_rules[ruleAction44]() {
					goto l101
				}
				add(ruleFuncName, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 16 FuncArgs <- <(FuncArg (Space ',' Space FuncArg)* Space)> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				if !_rules[ruleFuncArg]() {
					goto l114
				}
			l116:
				{
					position117, tokenIndex117 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l117
					}
					if buffer[position] != rune(',') {
						goto l117
					}
					position++
					if !_rules[ruleSpace]() {
						goto l117
					}
					if !_rules[ruleFuncArg]() {
						goto l117
					}
					goto l116
				l117:
					position, tokenIndex = position117, tokenIndex117
				}
				if !_rules[ruleSpace]() {
					goto l114
				}
				add(ruleFuncArgs, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 17 FuncArg <- <(Expr Action45)> */
		func() bool {
			position118, tokenIndex118 := position, tokenIndex
			{
				position119 := position
				if !_rules[ruleExpr]() {
					goto l118
				}
				if !_rules[ruleAction45]() {
					goto l118
				}
				add(ruleFuncArg, position119)
			}
			return true
		l118:
			position, tokenIndex = position118, tokenIndex118
			return false
		},
		/* 18 Identifier <- <(('l' 'v' 'l' Action46) / ('m' 's' 'g' Action47) / ('k' 'v' Action48))> */
		func() bool {
			position120, tokenIndex120 := position, tokenIndex
			{
				position121 := position
				{
					position122, tokenIndex122 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l123
					}
					position++
					if buffer[position] != rune('v') {
						goto l123
					}
					position++
					if buffer[position] != rune('l') {
						goto l123
					}
					position++
					if !_rules[ruleAction46]() {
						goto l123
					}
					goto l122
				l123:
					position, tokenIndex = position122, tokenIndex122
					if buffer[position] != rune('m') {
						goto l124
					}
					position++
					if buffer[position] != rune('s') {
						goto l124
					}
					position++
					if buffer[position] != rune('g') {
						goto l124
					}
					position++
					if !_rules[ruleAction47]() {
						goto l124
					}
					goto l122
				l124:
					position, tokenIndex = position122, tokenIndex122
					if buffer[position] != rune('k') {
						goto l120
					}
					position++
					if buffer[position] != rune('v') {
						goto l120
					}
					position++
					if !_rules[ruleAction48]() {
						goto l120
					}
				}
			l122:
				add(ruleIdentifier, position121)
			}
			return true
		l120:
			position, tokenIndex = position120, tokenIndex120
			return false
		},
		/* 19 String <- <(<('"' StringChar* '"')> Action49)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127 := position
					if buffer[position] != rune('"') {
						goto l125
					}
					position++
				l128:
					{
						position129, tokenIndex129 := position, tokenIndex
						if !_rules[ruleStringChar]() {
							goto l129
						}
						goto l128
					l129:
						position, tokenIndex = position129, tokenIndex129
					}
					if buffer[position] != rune('"') {
						goto l125
					}
					position++
					add(rulePegText, position127)
				}
				if !_rules[ruleAction49]() {
					goto l125
				}
				add(ruleString, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 20 SelectorId <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				{
					position132, tokenIndex132 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l133
					}
					position++
					goto l132
				l133:
					position, tokenIndex = position132, tokenIndex132
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l134
					}
					position++
					goto l132
				l134:
					position, tokenIndex = position132, tokenIndex132
					if buffer[position] != rune('_') {
						goto l130
					}
					position++
				}
			l132:
			l135:
				{
					position136, tokenIndex136 := position, tokenIndex
					{
						position137, tokenIndex137 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l138
						}
						position++
						goto l137
					l138:
						position, tokenIndex = position137, tokenIndex137
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l139
						}
						position++
						goto l137
					l139:
						position, tokenIndex = position137, tokenIndex137
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l140
						}
						position++
						goto l137
					l140:
						position, tokenIndex = position137, tokenIndex137
						if buffer[position] != rune('_') {
							goto l136
						}
						position++
					}
				l137:
					goto l135
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
				add(ruleSelectorId, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 21 F64 <- <((<(Digits '.' Digits? Exponent?)> Action50) / (<('.' Digits Exponent?)> Action51) / (<(Digits Exponent)> Action52))> */
		func() bool {
			position141, tokenIndex141 := position, tokenIndex
			{
				position142 := position
				{
					position143, tokenIndex143 := position, tokenIndex
					{
						position145 := position
						if !_rules[ruleDigits]() {
							goto l144
						}
						if buffer[position] != rune('.') {
							goto l144
						}
						position++
						{
							position146, tokenIndex146 := position, tokenIndex
							if !_rules[ruleDigits]() {
								goto l146
							}
							goto l147
						l146:
							position, tokenIndex = position146, tokenIndex146
						}
					l147:
						{
							position148, tokenIndex148 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l148
							}
							goto l149
						l148:
							position, tokenIndex = position148, tokenIndex148
						}
					l149:
						add(rulePegText, position145)
					}
					if !_rules[ruleAction50]() {
						goto l144
					}
					goto l143
				l144:
					position, tokenIndex = position143, tokenIndex143
					{
						position151 := position
						if buffer[position] != rune('.') {
							goto l150
						}
						position++
						if !_rules[ruleDigits]() {
							goto l150
						}
						{
							position152, tokenIndex152 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l152
							}
							goto l153
						l152:
							position, tokenIndex = position152, tokenIndex152
						}
					l153:
						add(rulePegText, position151)
					}
					if !_rules[ruleAction51]() {
						goto l150
					}
					goto l143
				l150:
					position, tokenIndex = position143, tokenIndex143
					{
						position154 := position
						if !_rules[ruleDigits]() {
							goto l141
						}
						if !_rules[ruleExponent]() {
							goto l141
						}
						add(rulePegText, position154)
					}
					if !_rules[ruleAction52]() {
						goto l141
					}
				}
			l143:
				add(ruleF64, position142)
			}
			return true
		l141:
			position, tokenIndex = position141, tokenIndex141
			return false
		},
		/* 22 I64 <- <(('0' Action53) / (<([1-9] ('_'* [0-9])*)> Action54))> */
		func() bool {
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				{
					position157, tokenIndex157 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l158
					}
					position++
					if !_rules[ruleAction53]() {
						goto l158
					}
					goto l157
				l158:
					position, tokenIndex = position157, tokenIndex157
					{
						position159 := position
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l155
						}
						position++
					l160:
						{
							position161, tokenIndex161 := position, tokenIndex
						l162:
							{
								position163, tokenIndex163 := position, tokenIndex
								if buffer[position] != rune('_') {
									goto l163
								}
								position++
								goto l162
							l163:
								position, tokenIndex = position163, tokenIndex163
							}
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l161
							}
							position++
							goto l160
						l161:
							position, tokenIndex = position161, tokenIndex161
						}
						add(rulePegText, position159)
					}
					if !_rules[ruleAction54]() {
						goto l155
					}
				}
			l157:
				add(ruleI64, position156)
			}
			return true
		l155:
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 23 Bool <- <(('t' 'r' 'u' 'e' Action55) / ('f' 'a' 'l' 's' 'e' Action56))> */
		func() bool {
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				{
					position166, tokenIndex166 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l167
					}
					position++
					if buffer[position] != rune('r') {
						goto l167
					}
					position++
					if buffer[position] != rune('u') {
						goto l167
					}
					position++
					if buffer[position] != rune('e') {
						goto l167
					}
					position++
					if !_rules[ruleAction55]() {
						goto l167
					}
					goto l166
				l167:
					position, tokenIndex = position166, tokenIndex166
					if buffer[position] != rune('f') {
						goto l164
					}
					position++
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('l') {
						goto l164
					}
					position++
					if buffer[position] != rune('s') {
						goto l164
					}
					position++
					if buffer[position] != rune('e') {
						goto l164
					}
					position++
					if !_rules[ruleAction56]() {
						goto l164
					}
				}
			l166:
				add(ruleBool, position165)
			}
			return true
		l164:
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 24 ReservedKeyword <- <(Identifier / Bool)> */
		func() bool {
			position168, tokenIndex168 := position, tokenIndex
			{
				position169 := position
				{
					position170, tokenIndex170 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l171
					}
					goto l170
				l171:
					position, tokenIndex = position170, tokenIndex170
					if !_rules[ruleBool]() {
						goto l168
					}
				}
			l170:
				add(ruleReservedKeyword, position169)
			}
			return true
		l168:
			position, tokenIndex = position168, tokenIndex168
			return false
		},
		/* 25 Array <- <(L_BRACKET Action57 (ArrayItem (COMMA ArrayItem)*)? R_BRACKET)> */
		func() bool {
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				if !_rules[ruleL_BRACKET]() {
					goto l172
				}
				if !_rules[ruleAction57]() {
					goto l172
				}
				{
					position174, tokenIndex174 := position, tokenIndex
					if !_rules[ruleArrayItem]() {
						goto l174
					}
				l176:
					{
						position177, tokenIndex177 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l177
						}
						if !_rules[ruleArrayItem]() {
							goto l177
						}
						goto l176
					l177:
						position, tokenIndex = position177, tokenIndex177
					}
					goto l175
				l174:
					position, tokenIndex = position174, tokenIndex174
				}
			l175:
				if !_rules[ruleR_BRACKET]() {
					goto l172
				}
				add(ruleArray, position173)
			}
			return true
		l172:
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 26 ArrayItem <- <(Literal Action58)> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				if !_rules[ruleLiteral]() {
					goto l178
				}
				if !_rules[ruleAction58]() {
					goto l178
				}
				add(ruleArrayItem, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 27 Object <- <(L_SQUIGGLY Action59 (ObjectItem (COMMA ObjectItem)*)? R_SQUIGGLY)> */
		func() bool {
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l180
				}
				if !_rules[ruleAction59]() {
					goto l180
				}
				{
					position182, tokenIndex182 := position, tokenIndex
					if !_rules[ruleObjectItem]() {
						goto l182
					}
				l184:
					{
						position185, tokenIndex185 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l185
						}
						if !_rules[ruleObjectItem]() {
							goto l185
						}
						goto l184
					l185:
						position, tokenIndex = position185, tokenIndex185
					}
					goto l183
				l182:
					position, tokenIndex = position182, tokenIndex182
				}
			l183:
				if !_rules[ruleR_SQUIGGLY]() {
					goto l180
				}
				add(ruleObject, position181)
			}
			return true
		l180:
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 28 ObjectItem <- <(ObjectKey COLON Literal Action60)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				if !_rules[ruleObjectKey]() {
					goto l186
				}
				if !_rules[ruleCOLON]() {
					goto l186
				}
				if !_rules[ruleLiteral]() {
					goto l186
				}
				if !_rules[ruleAction60]() {
					goto l186
				}
				add(ruleObjectItem, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 29 ObjectKey <- <(String Action61)> */
		func() bool {
			position188, tokenIndex188 := position, tokenIndex
			{
				position189 := position
				if !_rules[ruleString]() {
					goto l188
				}
				if !_rules[ruleAction61]() {
					goto l188
				}
				add(ruleObjectKey, position189)
			}
			return true
		l188:
			position, tokenIndex = position188, tokenIndex188
			return false
		},
		/* 30 Duration <- <((F64 <(('u' 's') / ('' 's') / ('m' 's') / 's' / 'm' / 'h')> Action62) / (I64 <(('n' 's') / ('u' 's') / ('' 's') / ('m' 's') / 's' / 'm' / 'h')> Action63))> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				{
					position192, tokenIndex192 := position, tokenIndex
					if !_rules[ruleF64]() {
						goto l193
					}
					{
						position194 := position
						{
							position195, tokenIndex195 := position, tokenIndex
							if buffer[position] != rune('u') {
								goto l196
							}
							position++
							if buffer[position] != rune('s') {
								goto l196
							}
							position++
							goto l195
						l196:
							position, tokenIndex = position195, tokenIndex195
							if buffer[position] != rune('') {
								goto l197
							}
							position++
							if buffer[position] != rune('s') {
								goto l197
							}
							position++
							goto l195
						l197:
							position, tokenIndex = position195, tokenIndex195
							if buffer[position] != rune('m') {
								goto l198
							}
							position++
							if buffer[position] != rune('s') {
								goto l198
							}
							position++
							goto l195
						l198:
							position, tokenIndex = position195, tokenIndex195
							if buffer[position] != rune('s') {
								goto l199
							}
							position++
							goto l195
						l199:
							position, tokenIndex = position195, tokenIndex195
							if buffer[position] != rune('m') {
								goto l200
							}
							position++
							goto l195
						l200:
							position, tokenIndex = position195, tokenIndex195
							if buffer[position] != rune('h') {
								goto l193
							}
							position++
						}
					l195:
						add(rulePegText, position194)
					}
					if !_rules[ruleAction62]() {
						goto l193
					}
					goto l192
				l193:
					position, tokenIndex = position192, tokenIndex192
					if !_rules[ruleI64]() {
						goto l190
					}
					{
						position201 := position
						{
							position202, tokenIndex202 := position, tokenIndex
							if buffer[position] != rune('n') {
								goto l203
							}
							position++
							if buffer[position] != rune('s') {
								goto l203
							}
							position++
							goto l202
						l203:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('u') {
								goto l204
							}
							position++
							if buffer[position] != rune('s') {
								goto l204
							}
							position++
							goto l202
						l204:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('') {
								goto l205
							}
							position++
							if buffer[position] != rune('s') {
								goto l205
							}
							position++
							goto l202
						l205:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('m') {
								goto l206
							}
							position++
							if buffer[position] != rune('s') {
								goto l206
							}
							position++
							goto l202
						l206:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('s') {
								goto l207
							}
							position++
							goto l202
						l207:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('m') {
								goto l208
							}
							position++
							goto l202
						l208:
							position, tokenIndex = position202, tokenIndex202
							if buffer[position] != rune('h') {
								goto l190
							}
							position++
						}
					l202:
						add(rulePegText, position201)
					}
					if !_rules[ruleAction63]() {
						goto l190
					}
				}
			l192:
				add(ruleDuration, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 31 Timestamp <- <(<RFC3339Nano> Action64)> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				{
					position211 := position
					if !_rules[ruleRFC3339Nano]() {
						goto l209
					}
					add(rulePegText, position211)
				}
				if !_rules[ruleAction64]() {
					goto l209
				}
				add(ruleTimestamp, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 32 StringChar <- <(('\\' ('\'' / '"' / '?' / '\\' / '%' / 'a' / 'b' / 'f' / 'n' / 'r' / 't' / 'v')) / (!('"' / '\n' / '\\') .))> */
		func() bool {
			position212, tokenIndex212 := position, tokenIndex
			{
				position213 := position
				{
					position214, tokenIndex214 := position, tokenIndex
					if buffer[position] != rune('\\') {
						goto l215
					}
					position++
					{
						position216, tokenIndex216 := position, tokenIndex
						if buffer[position] != rune('\'') {
							goto l217
						}
						position++
						goto l216
					l217:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('"') {
							goto l218
						}
						position++
						goto l216
					l218:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('?') {
							goto l219
						}
						position++
						goto l216
					l219:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('\\') {
							goto l220
						}
						position++
						goto l216
					l220:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('%') {
							goto l221
						}
						position++
						goto l216
					l221:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('a') {
							goto l222
						}
						position++
						goto l216
					l222:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('b') {
							goto l223
						}
						position++
						goto l216
					l223:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('f') {
							goto l224
						}
						position++
						goto l216
					l224:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('n') {
							goto l225
						}
						position++
						goto l216
					l225:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('r') {
							goto l226
						}
						position++
						goto l216
					l226:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('t') {
							goto l227
						}
						position++
						goto l216
					l227:
						position, tokenIndex = position216, tokenIndex216
						if buffer[position] != rune('v') {
							goto l215
						}
						position++
					}
				l216:
					goto l214
				l215:
					position, tokenIndex = position214, tokenIndex214
					{
						position228, tokenIndex228 := position, tokenIndex
						{
							position229, tokenIndex229 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l230
							}
							position++
							goto l229
						l230:
							position, tokenIndex = position229, tokenIndex229
							if buffer[position] != rune('\n') {
								goto l231
							}
							position++
							goto l229
						l231:
							position, tokenIndex = position229, tokenIndex229
							if buffer[position] != rune('\\') {
								goto l228
							}
							position++
						}
					l229:
						goto l212
					l228:
						position, tokenIndex = position228, tokenIndex228
					}
					if !matchDot() {
						goto l212
					}
				}
			l214:
				add(ruleStringChar, position213)
			}
			return true
		l212:
			position, tokenIndex = position212, tokenIndex212
			return false
		},
		/* 33 Exponent <- <(('e' / 'E') ('+' / '-')? Digits)> */
		func() bool {
			position232, tokenIndex232 := position, tokenIndex
			{
				position233 := position
				{
					position234, tokenIndex234 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l235
					}
					position++
					goto l234
				l235:
					position, tokenIndex = position234, tokenIndex234
					if buffer[position] != rune('E') {
						goto l232
					}
					position++
				}
			l234:
				{
					position236, tokenIndex236 := position, tokenIndex
					{
						position238, tokenIndex238 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l239
						}
						position++
						goto l238
					l239:
						position, tokenIndex = position238, tokenIndex238
						if buffer[position] != rune('-') {
							goto l236
						}
						position++
					}
				l238:
					goto l237
				l236:
					position, tokenIndex = position236, tokenIndex236
				}
			l237:
				if !_rules[ruleDigits]() {
					goto l232
				}
				add(ruleExponent, position233)
			}
			return true
		l232:
			position, tokenIndex = position232, tokenIndex232
			return false
		},
		/* 34 Digits <- <([0-9] ('_'* [0-9])*)> */
		func() bool {
			position240, tokenIndex240 := position, tokenIndex
			{
				position241 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l240
				}
				position++
			l242:
				{
					position243, tokenIndex243 := position, tokenIndex
				l244:
					{
						position245, tokenIndex245 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l245
						}
						position++
						goto l244
					l245:
						position, tokenIndex = position245, tokenIndex245
					}
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l243
					}
					position++
					goto l242
				l243:
					position, tokenIndex = position243, tokenIndex243
				}
				add(ruleDigits, position241)
			}
			return true
		l240:
			position, tokenIndex = position240, tokenIndex240
			return false
		},
		/* 35 RFC3339Nano <- <(RFC3339NanoDate 'T' RFC3339NanoTime RFC3339NanoTimezone)> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				if !_rules[ruleRFC3339NanoDate]() {
					goto l246
				}
				if buffer[position] != rune('T') {
					goto l246
				}
				position++
				if !_rules[ruleRFC3339NanoTime]() {
					goto l246
				}
				if !_rules[ruleRFC3339NanoTimezone]() {
					goto l246
				}
				add(ruleRFC3339Nano, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 36 RFC3339NanoDate <- <(Number '-' Number '-' Number)> */
		func() bool {
			position248, tokenIndex248 := position, tokenIndex
			{
				position249 := position
				if !_rules[ruleNumber]() {
					goto l248
				}
				if buffer[position] != rune('-') {
					goto l248
				}
				position++
				if !_rules[ruleNumber]() {
					goto l248
				}
				if buffer[position] != rune('-') {
					goto l248
				}
				position++
				if !_rules[ruleNumber]() {
					goto l248
				}
				add(ruleRFC3339NanoDate, position249)
			}
			return true
		l248:
			position, tokenIndex = position248, tokenIndex248
			return false
		},
		/* 37 RFC3339NanoTime <- <(Number ':' Number ':' Number ('.' Number)?)> */
		func() bool {
			position250, tokenIndex250 := position, tokenIndex
			{
				position251 := position
				if !_rules[ruleNumber]() {
					goto l250
				}
				if buffer[position] != rune(':') {
					goto l250
				}
				position++
				if !_rules[ruleNumber]() {
					goto l250
				}
				if buffer[position] != rune(':') {
					goto l250
				}
				position++
				if !_rules[ruleNumber]() {
					goto l250
				}
				{
					position252, tokenIndex252 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l252
					}
					position++
					if !_rules[ruleNumber]() {
						goto l252
					}
					goto l253
				l252:
					position, tokenIndex = position252, tokenIndex252
				}
			l253:
				add(ruleRFC3339NanoTime, position251)
			}
			return true
		l250:
			position, tokenIndex = position250, tokenIndex250
			return false
		},
		/* 38 RFC3339NanoTimezone <- <('Z' / ('+' Number ':' Number))> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				{
					position256, tokenIndex256 := position, tokenIndex
					if buffer[position] != rune('Z') {
						goto l257
					}
					position++
					goto l256
				l257:
					position, tokenIndex = position256, tokenIndex256
					if buffer[position] != rune('+') {
						goto l254
					}
					position++
					if !_rules[ruleNumber]() {
						goto l254
					}
					if buffer[position] != rune(':') {
						goto l254
					}
					position++
					if !_rules[ruleNumber]() {
						goto l254
					}
				}
			l256:
				add(ruleRFC3339NanoTimezone, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 39 Number <- <<[0-9]+>> */
		func() bool {
			position258, tokenIndex258 := position, tokenIndex
			{
				position259 := position
				{
					position260 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l258
					}
					position++
				l261:
					{
						position262, tokenIndex262 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l262
						}
						position++
						goto l261
					l262:
						position, tokenIndex = position262, tokenIndex262
					}
					add(rulePegText, position260)
				}
				add(ruleNumber, position259)
			}
			return true
		l258:
			position, tokenIndex = position258, tokenIndex258
			return false
		},
		/* 40 NOT <- <('!' Space)> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				if buffer[position] != rune('!') {
					goto l263
				}
				position++
				if !_rules[ruleSpace]() {
					goto l263
				}
				add(ruleNOT, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 41 NEG <- <('-' Space)> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				if buffer[position] != rune('-') {
					goto l265
				}
				position++
				if !_rules[ruleSpace]() {
					goto l265
				}
				add(ruleNEG, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 42 NUM_ADD <- <('+' Space)> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				if buffer[position] != rune('+') {
					goto l267
				}
				position++
				if !_rules[ruleSpace]() {
					goto l267
				}
				add(ruleNUM_ADD, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 43 NUM_SUB <- <('-' Space)> */
		func() bool {
			position269, tokenIndex269 := position, tokenIndex
			{
				position270 := position
				if buffer[position] != rune('-') {
					goto l269
				}
				position++
				if !_rules[ruleSpace]() {
					goto l269
				}
				add(ruleNUM_SUB, position270)
			}
			return true
		l269:
			position, tokenIndex = position269, tokenIndex269
			return false
		},
		/* 44 NUM_DIV <- <('/' Space)> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				if buffer[position] != rune('/') {
					goto l271
				}
				position++
				if !_rules[ruleSpace]() {
					goto l271
				}
				add(ruleNUM_DIV, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 45 NUM_MUL <- <('*' Space)> */
		func() bool {
			position273, tokenIndex273 := position, tokenIndex
			{
				position274 := position
				if buffer[position] != rune('*') {
					goto l273
				}
				position++
				if !_rules[ruleSpace]() {
					goto l273
				}
				add(ruleNUM_MUL, position274)
			}
			return true
		l273:
			position, tokenIndex = position273, tokenIndex273
			return false
		},
		/* 46 LOG_AND <- <('&' '&' Space)> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				if buffer[position] != rune('&') {
					goto l275
				}
				position++
				if buffer[position] != rune('&') {
					goto l275
				}
				position++
				if !_rules[ruleSpace]() {
					goto l275
				}
				add(ruleLOG_AND, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 47 LOG_OR <- <('|' '|' Space)> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				if buffer[position] != rune('|') {
					goto l277
				}
				position++
				if buffer[position] != rune('|') {
					goto l277
				}
				position++
				if !_rules[ruleSpace]() {
					goto l277
				}
				add(ruleLOG_OR, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 48 CMP_EQ <- <('=' Space)> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				if buffer[position] != rune('=') {
					goto l279
				}
				position++
				if !_rules[ruleSpace]() {
					goto l279
				}
				add(ruleCMP_EQ, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 49 CMP_NOTEQ <- <('!' '=' Space)> */
		func() bool {
			position281, tokenIndex281 := position, tokenIndex
			{
				position282 := position
				if buffer[position] != rune('!') {
					goto l281
				}
				position++
				if buffer[position] != rune('=') {
					goto l281
				}
				position++
				if !_rules[ruleSpace]() {
					goto l281
				}
				add(ruleCMP_NOTEQ, position282)
			}
			return true
		l281:
			position, tokenIndex = position281, tokenIndex281
			return false
		},
		/* 50 CMP_GT <- <('>' Space)> */
		func() bool {
			position283, tokenIndex283 := position, tokenIndex
			{
				position284 := position
				if buffer[position] != rune('>') {
					goto l283
				}
				position++
				if !_rules[ruleSpace]() {
					goto l283
				}
				add(ruleCMP_GT, position284)
			}
			return true
		l283:
			position, tokenIndex = position283, tokenIndex283
			return false
		},
		/* 51 CMP_GTE <- <('>' '=' Space)> */
		func() bool {
			position285, tokenIndex285 := position, tokenIndex
			{
				position286 := position
				if buffer[position] != rune('>') {
					goto l285
				}
				position++
				if buffer[position] != rune('=') {
					goto l285
				}
				position++
				if !_rules[ruleSpace]() {
					goto l285
				}
				add(ruleCMP_GTE, position286)
			}
			return true
		l285:
			position, tokenIndex = position285, tokenIndex285
			return false
		},
		/* 52 CMP_LT <- <('<' Space)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if buffer[position] != rune('<') {
					goto l287
				}
				position++
				if !_rules[ruleSpace]() {
					goto l287
				}
				add(ruleCMP_LT, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 53 CMP_LTE <- <('<' '=' Space)> */
		func() bool {
			position289, tokenIndex289 := position, tokenIndex
			{
				position290 := position
				if buffer[position] != rune('<') {
					goto l289
				}
				position++
				if buffer[position] != rune('=') {
					goto l289
				}
				position++
				if !_rules[ruleSpace]() {
					goto l289
				}
				add(ruleCMP_LTE, position290)
			}
			return true
		l289:
			position, tokenIndex = position289, tokenIndex289
			return false
		},
		/* 54 SET_IN <- <('i' 'n' Space)> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				if buffer[position] != rune('i') {
					goto l291
				}
				position++
				if buffer[position] != rune('n') {
					goto l291
				}
				position++
				if !_rules[ruleSpace]() {
					goto l291
				}
				add(ruleSET_IN, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 55 SET_NOTIN <- <('n' 'o' 't' ' ' 'i' 'n' Space)> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				if buffer[position] != rune('n') {
					goto l293
				}
				position++
				if buffer[position] != rune('o') {
					goto l293
				}
				position++
				if buffer[position] != rune('t') {
					goto l293
				}
				position++
				if buffer[position] != rune(' ') {
					goto l293
				}
				position++
				if buffer[position] != rune('i') {
					goto l293
				}
				position++
				if buffer[position] != rune('n') {
					goto l293
				}
				position++
				if !_rules[ruleSpace]() {
					goto l293
				}
				add(ruleSET_NOTIN, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 56 PIPE <- <('|' Space)> */
		func() bool {
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				if buffer[position] != rune('|') {
					goto l295
				}
				position++
				if !_rules[ruleSpace]() {
					goto l295
				}
				add(rulePIPE, position296)
			}
			return true
		l295:
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 57 DOT <- <('.' Space)> */
		func() bool {
			position297, tokenIndex297 := position, tokenIndex
			{
				position298 := position
				if buffer[position] != rune('.') {
					goto l297
				}
				position++
				if !_rules[ruleSpace]() {
					goto l297
				}
				add(ruleDOT, position298)
			}
			return true
		l297:
			position, tokenIndex = position297, tokenIndex297
			return false
		},
		/* 58 L_PARENS <- <('(' Space)> */
		func() bool {
			position299, tokenIndex299 := position, tokenIndex
			{
				position300 := position
				if buffer[position] != rune('(') {
					goto l299
				}
				position++
				if !_rules[ruleSpace]() {
					goto l299
				}
				add(ruleL_PARENS, position300)
			}
			return true
		l299:
			position, tokenIndex = position299, tokenIndex299
			return false
		},
		/* 59 R_PARENS <- <(')' Space)> */
		func() bool {
			position301, tokenIndex301 := position, tokenIndex
			{
				position302 := position
				if buffer[position] != rune(')') {
					goto l301
				}
				position++
				if !_rules[ruleSpace]() {
					goto l301
				}
				add(ruleR_PARENS, position302)
			}
			return true
		l301:
			position, tokenIndex = position301, tokenIndex301
			return false
		},
		/* 60 L_BRACKET <- <('[' Space)> */
		func() bool {
			position303, tokenIndex303 := position, tokenIndex
			{
				position304 := position
				if buffer[position] != rune('[') {
					goto l303
				}
				position++
				if !_rules[ruleSpace]() {
					goto l303
				}
				add(ruleL_BRACKET, position304)
			}
			return true
		l303:
			position, tokenIndex = position303, tokenIndex303
			return false
		},
		/* 61 R_BRACKET <- <(']' Space)> */
		func() bool {
			position305, tokenIndex305 := position, tokenIndex
			{
				position306 := position
				if buffer[position] != rune(']') {
					goto l305
				}
				position++
				if !_rules[ruleSpace]() {
					goto l305
				}
				add(ruleR_BRACKET, position306)
			}
			return true
		l305:
			position, tokenIndex = position305, tokenIndex305
			return false
		},
		/* 62 L_SQUIGGLY <- <('{' Space)> */
		func() bool {
			position307, tokenIndex307 := position, tokenIndex
			{
				position308 := position
				if buffer[position] != rune('{') {
					goto l307
				}
				position++
				if !_rules[ruleSpace]() {
					goto l307
				}
				add(ruleL_SQUIGGLY, position308)
			}
			return true
		l307:
			position, tokenIndex = position307, tokenIndex307
			return false
		},
		/* 63 R_SQUIGGLY <- <'}'> */
		func() bool {
			position309, tokenIndex309 := position, tokenIndex
			{
				position310 := position
				if buffer[position] != rune('}') {
					goto l309
				}
				position++
				add(ruleR_SQUIGGLY, position310)
			}
			return true
		l309:
			position, tokenIndex = position309, tokenIndex309
			return false
		},
		/* 64 COLON <- <(':' Space)> */
		func() bool {
			position311, tokenIndex311 := position, tokenIndex
			{
				position312 := position
				if buffer[position] != rune(':') {
					goto l311
				}
				position++
				if !_rules[ruleSpace]() {
					goto l311
				}
				add(ruleCOLON, position312)
			}
			return true
		l311:
			position, tokenIndex = position311, tokenIndex311
			return false
		},
		/* 65 COMMA <- <(',' Space)> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if buffer[position] != rune(',') {
					goto l313
				}
				position++
				if !_rules[ruleSpace]() {
					goto l313
				}
				add(ruleCOMMA, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 66 Space <- <Whitespace*> */
		func() bool {
			{
				position316 := position
			l317:
				{
					position318, tokenIndex318 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l318
					}
					goto l317
				l318:
					position, tokenIndex = position318, tokenIndex318
				}
				add(ruleSpace, position316)
			}
			return true
		},
		/* 67 MustSpace <- <Whitespace+> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				if !_rules[ruleWhitespace]() {
					goto l319
				}
			l321:
				{
					position322, tokenIndex322 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l322
					}
					goto l321
				l322:
					position, tokenIndex = position322, tokenIndex322
				}
				add(ruleMustSpace, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 68 Whitespace <- <(' ' / '\t' / EOL)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				{
					position325, tokenIndex325 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l326
					}
					position++
					goto l325
				l326:
					position, tokenIndex = position325, tokenIndex325
					if buffer[position] != rune('\t') {
						goto l327
					}
					position++
					goto l325
				l327:
					position, tokenIndex = position325, tokenIndex325
					if !_rules[ruleEOL]() {
						goto l323
					}
				}
			l325:
				add(ruleWhitespace, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 69 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				{
					position330, tokenIndex330 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l331
					}
					position++
					if buffer[position] != rune('\n') {
						goto l331
					}
					position++
					goto l330
				l331:
					position, tokenIndex = position330, tokenIndex330
					if buffer[position] != rune('\n') {
						goto l332
					}
					position++
					goto l330
				l332:
					position, tokenIndex = position330, tokenIndex330
					if buffer[position] != rune('\r') {
						goto l328
					}
					position++
				}
			l330:
				add(ruleEOL, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 70 EOF <- <!.> */
		func() bool {
			position333, tokenIndex333 := position, tokenIndex
			{
				position334 := position
				{
					position335, tokenIndex335 := position, tokenIndex
					if !matchDot() {
						goto l335
					}
					goto l333
				l335:
					position, tokenIndex = position335, tokenIndex335
				}
				add(ruleEOF, position334)
			}
			return true
		l333:
			position, tokenIndex = position333, tokenIndex333
			return false
		},
		/* 72 Action0 <- <{ p.SetQuery(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		/* 73 Action1 <- <{ p.SetQuery(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 74 Action2 <- <{ p.SetFrom(p.Timestamp) }> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 75 Action3 <- <{ p.SetTo(p.Timestamp) }> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 76 Action4 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 77 Action5 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 78 Action6 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 79 Action7 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 80 Action8 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 81 Action9 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 82 Action10 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 83 Action11 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 84 Action12 <- <{ tail, head := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprPipe(head, tail)) }> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 85 Action13 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs)) }> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 86 Action14 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs)) }> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 87 Action15 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs)) }> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 88 Action16 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs)) }> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 89 Action17 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs)) }> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 90 Action18 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs)) }> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 91 Action19 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 92 Action20 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 93 Action21 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs)) }> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 94 Action22 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 95 Action23 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs)) }> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 96 Action24 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 97 Action25 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs)) }> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 98 Action26 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs)) }> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 99 Action27 <- <{ index, x := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprIndexor(x, index)) }> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		nil,
		/* 101 Action28 <- <{ selector, x := text, p.popExpr(); p.pushExpr(typesv1.ExprSelector(x, selector)) }> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 102 Action29 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 103 Action30 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg)) }> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 104 Action31 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 105 Action32 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg)) }> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 106 Action33 <- <{ p.pushExpr(typesv1.ExprLiteral(p.Literal)); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 107 Action34 <- <{ p.Literal = typesv1.ValStr(p.String) }> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 108 Action35 <- <{ p.Literal = typesv1.ValDuration(p.Duration) }> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 109 Action36 <- <{ p.Literal = typesv1.ValTime(p.Timestamp) }> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 110 Action37 <- <{ p.Literal = typesv1.ValF64(p.F64) }> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 111 Action38 <- <{ p.Literal = typesv1.ValI64(p.I64) }> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 112 Action39 <- <{ p.Literal = typesv1.ValBool(p.Bool) }> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 113 Action40 <- <{ p.Literal = typesv1.ValArr(p.popArray()...) }> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 114 Action41 <- <{ p.Literal = typesv1.ValObj(p.popObj()...) }> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 115 Action42 <- <{ p.pushFunc() }> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 116 Action43 <- <{ p.pushExpr(p.popFunc()) }> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		/* 117 Action44 <- <{ p.setFuncName(text) }> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 118 Action45 <- <{ p.addFuncArg(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
		/* 119 Action46 <- <{ p.pushExpr(typesv1.ExprIdentifier("lvl")) }> */
		func() bool {
			{
				add(ruleAction46, position)
			}
			return true
		},
		/* 120 Action47 <- <{ p.pushExpr(typesv1.ExprIdentifier("msg")) }> */
		func() bool {
			{
				add(ruleAction47, position)
			}
			return true
		},
		/* 121 Action48 <- <{ p.pushExpr(typesv1.ExprIdentifier("kv")) }> */
		func() bool {
			{
				add(ruleAction48, position)
			}
			return true
		},
		/* 122 Action49 <- <{ p.String = p.parseString(text) }> */
		func() bool {
			{
				add(ruleAction49, position)
			}
			return true
		},
		/* 123 Action50 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction50, position)
			}
			return true
		},
		/* 124 Action51 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction51, position)
			}
			return true
		},
		/* 125 Action52 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction52, position)
			}
			return true
		},
		/* 126 Action53 <- <{ p.I64 = 0 }> */
		func() bool {
			{
				add(ruleAction53, position)
			}
			return true
		},
		/* 127 Action54 <- <{ p.I64 = p.parseInt64(text) }> */
		func() bool {
			{
				add(ruleAction54, position)
			}
			return true
		},
		/* 128 Action55 <- <{ p.Bool = true }> */
		func() bool {
			{
				add(ruleAction55, position)
			}
			return true
		},
		/* 129 Action56 <- <{ p.Bool = false }> */
		func() bool {
			{
				add(ruleAction56, position)
			}
			return true
		},
		/* 130 Action57 <- <{ p.pushArray() }> */
		func() bool {
			{
				add(ruleAction57, position)
			}
			return true
		},
		/* 131 Action58 <- <{ p.addArrItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction58, position)
			}
			return true
		},
		/* 132 Action59 <- <{ p.pushObj() }> */
		func() bool {
			{
				add(ruleAction59, position)
			}
			return true
		},
		/* 133 Action60 <- <{ p.closeObjItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction60, position)
			}
			return true
		},
		/* 134 Action61 <- <{ p.startObjItem(p.String) }> */
		func() bool {
			{
				add(ruleAction61, position)
			}
			return true
		},
		/* 135 Action62 <- <{ p.Duration = p.parseDurationF64(p.F64, text) }> */
		func() bool {
			{
				add(ruleAction62, position)
			}
			return true
		},
		/* 136 Action63 <- <{ p.Duration = p.parseDurationI64(p.I64, text) }> */
		func() bool {
			{
				add(ruleAction63, position)
			}
			return true
		},
		/* 137 Action64 <- <{ p.Timestamp = p.parseTime(time.RFC3339Nano, text) }> */
		func() bool {
			{
				add(ruleAction64, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
