package logql

// Code generated by peg /Users/antoine/code/src/github.com/humanlogio/api/go/pkg/logql/grammar.peg DO NOT EDIT.

import (
	"fmt"
	"github.com/humanlogio/api/go/types/v1"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleQueryContext
	ruleQueryContextItem
	ruleQueryFrom
	ruleQueryTo
	ruleQueryMachineContext
	ruleQuerySessionContext
	ruleStatements
	ruleStatement
	ruleRenderStatement
	ruleFilterOperator
	ruleSummarizeOperator
	ruleSummarizeParameters
	ruleSummarizeParameter
	ruleSummarizeByGroupExpressions
	ruleSummarizeByGroupExpression
	ruleProjectOperator
	ruleProjectArg
	ruleRenderSplitOperator
	ruleRenderSplitByOperator
	ruleRenderSplitByOperatorArg
	ruleExpr
	ruleExpr1
	ruleExpr2
	ruleExpr3
	ruleExpr4
	ruleExpr5
	ruleLiteral
	ruleFuncCall
	ruleFuncName
	ruleFuncArgs
	ruleFuncArg
	ruleIdentifier
	ruleString
	ruleSelectorId
	ruleF64
	ruleI64
	ruleBool
	ruleReservedKeyword
	ruleArray
	ruleArrayItem
	ruleObject
	ruleObjectItem
	ruleObjectKey
	ruleDuration
	ruleTimestamp
	ruleStringChar
	ruleExponent
	ruleDigits
	ruleRFC3339Nano
	ruleRFC3339NanoDate
	ruleRFC3339NanoTime
	ruleRFC3339NanoTimezone
	ruleNumber
	ruleNOT
	ruleNEG
	ruleNUM_ADD
	ruleNUM_SUB
	ruleNUM_DIV
	ruleNUM_MUL
	ruleLOG_AND
	ruleLOG_OR
	ruleCMP_EQ
	ruleCMP_NOTEQ
	ruleCMP_GT
	ruleCMP_GTE
	ruleCMP_LT
	ruleCMP_LTE
	ruleSET_IN
	ruleSET_NOTIN
	rulePIPE
	ruleDOT
	ruleL_PARENS
	ruleR_PARENS
	ruleL_BRACKET
	ruleR_BRACKET
	ruleL_SQUIGGLY
	ruleR_SQUIGGLY
	ruleCOLON
	ruleCOMMA
	ruleSpace
	ruleMustSpace
	ruleWhitespace
	ruleEOL
	ruleEOF
	ruleAction0
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	rulePegText
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
	ruleAction49
	ruleAction50
	ruleAction51
	ruleAction52
	ruleAction53
	ruleAction54
	ruleAction55
	ruleAction56
	ruleAction57
	ruleAction58
	ruleAction59
	ruleAction60
	ruleAction61
	ruleAction62
	ruleAction63
	ruleAction64
	ruleAction65
	ruleAction66
	ruleAction67
	ruleAction68
	ruleAction69
	ruleAction70
	ruleAction71
	ruleAction72
	ruleAction73
	ruleAction74
	ruleAction75
	ruleAction76
	ruleAction77
	ruleAction78
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"QueryContext",
	"QueryContextItem",
	"QueryFrom",
	"QueryTo",
	"QueryMachineContext",
	"QuerySessionContext",
	"Statements",
	"Statement",
	"RenderStatement",
	"FilterOperator",
	"SummarizeOperator",
	"SummarizeParameters",
	"SummarizeParameter",
	"SummarizeByGroupExpressions",
	"SummarizeByGroupExpression",
	"ProjectOperator",
	"ProjectArg",
	"RenderSplitOperator",
	"RenderSplitByOperator",
	"RenderSplitByOperatorArg",
	"Expr",
	"Expr1",
	"Expr2",
	"Expr3",
	"Expr4",
	"Expr5",
	"Literal",
	"FuncCall",
	"FuncName",
	"FuncArgs",
	"FuncArg",
	"Identifier",
	"String",
	"SelectorId",
	"F64",
	"I64",
	"Bool",
	"ReservedKeyword",
	"Array",
	"ArrayItem",
	"Object",
	"ObjectItem",
	"ObjectKey",
	"Duration",
	"Timestamp",
	"StringChar",
	"Exponent",
	"Digits",
	"RFC3339Nano",
	"RFC3339NanoDate",
	"RFC3339NanoTime",
	"RFC3339NanoTimezone",
	"Number",
	"NOT",
	"NEG",
	"NUM_ADD",
	"NUM_SUB",
	"NUM_DIV",
	"NUM_MUL",
	"LOG_AND",
	"LOG_OR",
	"CMP_EQ",
	"CMP_NOTEQ",
	"CMP_GT",
	"CMP_GTE",
	"CMP_LT",
	"CMP_LTE",
	"SET_IN",
	"SET_NOTIN",
	"PIPE",
	"DOT",
	"L_PARENS",
	"R_PARENS",
	"L_BRACKET",
	"R_BRACKET",
	"L_SQUIGGLY",
	"R_SQUIGGLY",
	"COLON",
	"COMMA",
	"Space",
	"MustSpace",
	"Whitespace",
	"EOL",
	"EOF",
	"Action0",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"PegText",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
	"Action49",
	"Action50",
	"Action51",
	"Action52",
	"Action53",
	"Action54",
	"Action55",
	"Action56",
	"Action57",
	"Action58",
	"Action59",
	"Action60",
	"Action61",
	"Action62",
	"Action63",
	"Action64",
	"Action65",
	"Action66",
	"Action67",
	"Action68",
	"Action69",
	"Action70",
	"Action71",
	"Action72",
	"Action73",
	"Action74",
	"Action75",
	"Action76",
	"Action77",
	"Action78",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type logQL struct {

	// the query being built
	LogQuery *typesv1.LogQuery

	// stack for recursive generic structures
	Exprs []*typesv1.Expr

	// accumulate statements
	Stmts      []*typesv1.Statement
	RenderStmt *typesv1.RenderStatement

	// scratch space for table operators
	FilterOp    *typesv1.FilterOperator
	SummarizeOp *typesv1.SummarizeOperator
	ProjectOp   *typesv1.ProjectOperator

	// scratch space for render statements
	SplitByOp *typesv1.SplitOperator

	// scratch space, not needed but `Literal` being a type is convenient
	Literal *typesv1.Val

	// scalars
	String    string
	F64       float64
	I64       int64
	Bool      bool
	Timestamp time.Time
	Duration  time.Duration

	// stack for non-expr recursive structures
	Arrs      [][]*typesv1.Val
	ObjsKVs   [][]*typesv1.KV
	FuncCalls []*typesv1.FuncCall

	// errors seen along the way
	err error

	Buffer string
	buffer []rune
	rules  [166]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *logQL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *logQL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *logQL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *logQL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *logQL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *logQL) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func (p *logQL) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.SetQuery(p.Stmts)
		case ruleAction1:
			p.SetQuery(p.Stmts)
		case ruleAction2:
			p.SetFrom(p.popExpr())
		case ruleAction3:
			p.SetTo(p.popExpr())
		case ruleAction4:
			p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction5:
			p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction6:
			p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction7:
			p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction8:
			p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr())
		case ruleAction9:
			p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr())
		case ruleAction10:
			p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr())
		case ruleAction11:
			p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr())
		case ruleAction12:
			p.addFilterStatement(p.FilterOp)
		case ruleAction13:
			p.addSummarizeStatement(p.SummarizeOp)
		case ruleAction14:
			p.addProjectStatement(p.ProjectOp)
		case ruleAction15:
			p.setRenderSplitByStatement(p.SplitByOp)
		case ruleAction16:
			p.setFilterOp(p.popExpr())
		case ruleAction17:
			p.startSummarizeOp()
		case ruleAction18:
			p.startSummarizeParameterNamedFunc(text)
		case ruleAction19:
			p.endSummarizeParameterNamedFunc(p.popFunc())
		case ruleAction20:
			p.addSummarizeParameterUnnamedFunc(p.popFunc())
		case ruleAction21:
			p.startSummarizeByUnnamedGroupExpression(text)
		case ruleAction22:
			p.endSummarizeByUnnamedGroupExpression(p.popExpr())
		case ruleAction23:
			p.addSummarizeByUnnamedGroupExpression(p.popExpr())
		case ruleAction24:
			p.startProjectOp()
		case ruleAction25:
			p.startProjectOpArg(text)
		case ruleAction26:
			p.setProjectOpArgValue(p.popExpr())
		case ruleAction27:
			p.startRenderSplitOp()
		case ruleAction28:
			p.addRenderSplitByOp(p.popExpr())
		case ruleAction29:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs))
		case ruleAction30:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs))
		case ruleAction31:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs))
		case ruleAction32:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs))
		case ruleAction33:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs))
		case ruleAction34:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs))
		case ruleAction35:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs))
		case ruleAction36:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs))
		case ruleAction37:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs))
		case ruleAction38:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs))
		case ruleAction39:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs))
		case ruleAction40:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs))
		case ruleAction41:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs))
		case ruleAction42:
			rhs, lhs := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs))
		case ruleAction43:
			index, x := p.popExpr(), p.popExpr()
			p.pushExpr(typesv1.ExprIndexor(x, index))
		case ruleAction44:
			selector, x := text, p.popExpr()
			p.pushExpr(typesv1.ExprSelector(x, selector))
		case ruleAction45:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction46:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg))
		case ruleAction47:
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal)))
			p.Literal = nil
		case ruleAction48:
			arg := p.popExpr()
			p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg))
		case ruleAction49:
			p.pushExpr(typesv1.ExprLiteral(p.Literal))
			p.Literal = nil
		case ruleAction50:
			fn := p.popFunc()
			p.pushExpr(typesv1.ExprFuncCall(fn.Name, fn.Args...))
		case ruleAction51:
			p.Literal = typesv1.ValStr(p.String)
		case ruleAction52:
			p.Literal = typesv1.ValDuration(p.Duration)
		case ruleAction53:
			p.Literal = typesv1.ValTime(p.Timestamp)
		case ruleAction54:
			p.Literal = typesv1.ValF64(p.F64)
		case ruleAction55:
			p.Literal = typesv1.ValI64(p.I64)
		case ruleAction56:
			p.Literal = typesv1.ValBool(p.Bool)
		case ruleAction57:
			p.Literal = typesv1.ValArr(p.popArray()...)
		case ruleAction58:
			p.Literal = typesv1.ValObj(p.popObj()...)
		case ruleAction59:
			p.pushFunc()
		case ruleAction60:
			p.setFuncName(text)
		case ruleAction61:
			p.addFuncArg(p.popExpr())
		case ruleAction62:
			p.pushExpr(typesv1.ExprIdentifier(text))
		case ruleAction63:
			p.String = p.parseString(text)
		case ruleAction64:
			p.F64 = p.parseFloat64(text)
		case ruleAction65:
			p.F64 = p.parseFloat64(text)
		case ruleAction66:
			p.F64 = p.parseFloat64(text)
		case ruleAction67:
			p.I64 = 0
		case ruleAction68:
			p.I64 = p.parseInt64(text)
		case ruleAction69:
			p.Bool = true
		case ruleAction70:
			p.Bool = false
		case ruleAction71:
			p.pushArray()
		case ruleAction72:
			p.addArrItem(p.Literal)
			p.Literal = nil
		case ruleAction73:
			p.pushObj()
		case ruleAction74:
			p.closeObjItem(p.Literal)
			p.Literal = nil
		case ruleAction75:
			p.startObjItem(p.String)
		case ruleAction76:
			p.Duration = p.parseDurationF64(p.F64, text)
		case ruleAction77:
			p.Duration = p.parseDurationI64(p.I64, text)
		case ruleAction78:
			p.Timestamp = p.parseTime(time.RFC3339Nano, text)

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*logQL) error {
	return func(p *logQL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*logQL) error {
	return func(p *logQL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *logQL) Init(options ...func(*logQL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Space ((Statements Action0) / ((QueryContext MustSpace)? Statements Action1) / QueryContext)? RenderStatement? EOF)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpace]() {
					goto l0
				}
				{
					position2, tokenIndex2 := position, tokenIndex
					{
						position4, tokenIndex4 := position, tokenIndex
						if !_rules[ruleStatements]() {
							goto l5
						}
						if !_rules[ruleAction0]() {
							goto l5
						}
						goto l4
					l5:
						position, tokenIndex = position4, tokenIndex4
						{
							position7, tokenIndex7 := position, tokenIndex
							if !_rules[ruleQueryContext]() {
								goto l7
							}
							if !_rules[ruleMustSpace]() {
								goto l7
							}
							goto l8
						l7:
							position, tokenIndex = position7, tokenIndex7
						}
					l8:
						if !_rules[ruleStatements]() {
							goto l6
						}
						if !_rules[ruleAction1]() {
							goto l6
						}
						goto l4
					l6:
						position, tokenIndex = position4, tokenIndex4
						if !_rules[ruleQueryContext]() {
							goto l2
						}
					}
				l4:
					goto l3
				l2:
					position, tokenIndex = position2, tokenIndex2
				}
			l3:
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleRenderStatement]() {
						goto l9
					}
					goto l10
				l9:
					position, tokenIndex = position9, tokenIndex9
				}
			l10:
				if !_rules[ruleEOF]() {
					goto l0
				}
				add(ruleGrammar, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 QueryContext <- <(L_SQUIGGLY Space QueryContextItem+ R_SQUIGGLY)> */
		func() bool {
			position11, tokenIndex11 := position, tokenIndex
			{
				position12 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l11
				}
				if !_rules[ruleSpace]() {
					goto l11
				}
				if !_rules[ruleQueryContextItem]() {
					goto l11
				}
			l13:
				{
					position14, tokenIndex14 := position, tokenIndex
					if !_rules[ruleQueryContextItem]() {
						goto l14
					}
					goto l13
				l14:
					position, tokenIndex = position14, tokenIndex14
				}
				if !_rules[ruleR_SQUIGGLY]() {
					goto l11
				}
				add(ruleQueryContext, position12)
			}
			return true
		l11:
			position, tokenIndex = position11, tokenIndex11
			return false
		},
		/* 2 QueryContextItem <- <((QueryMachineContext / QuerySessionContext / QueryFrom / QueryTo) Space)> */
		func() bool {
			position15, tokenIndex15 := position, tokenIndex
			{
				position16 := position
				{
					position17, tokenIndex17 := position, tokenIndex
					if !_rules[ruleQueryMachineContext]() {
						goto l18
					}
					goto l17
				l18:
					position, tokenIndex = position17, tokenIndex17
					if !_rules[ruleQuerySessionContext]() {
						goto l19
					}
					goto l17
				l19:
					position, tokenIndex = position17, tokenIndex17
					if !_rules[ruleQueryFrom]() {
						goto l20
					}
					goto l17
				l20:
					position, tokenIndex = position17, tokenIndex17
					if !_rules[ruleQueryTo]() {
						goto l15
					}
				}
			l17:
				if !_rules[ruleSpace]() {
					goto l15
				}
				add(ruleQueryContextItem, position16)
			}
			return true
		l15:
			position, tokenIndex = position15, tokenIndex15
			return false
		},
		/* 3 QueryFrom <- <('f' 'r' 'o' 'm' Space CMP_EQ Space Expr Action2)> */
		func() bool {
			position21, tokenIndex21 := position, tokenIndex
			{
				position22 := position
				if buffer[position] != rune('f') {
					goto l21
				}
				position++
				if buffer[position] != rune('r') {
					goto l21
				}
				position++
				if buffer[position] != rune('o') {
					goto l21
				}
				position++
				if buffer[position] != rune('m') {
					goto l21
				}
				position++
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleCMP_EQ]() {
					goto l21
				}
				if !_rules[ruleSpace]() {
					goto l21
				}
				if !_rules[ruleExpr]() {
					goto l21
				}
				if !_rules[ruleAction2]() {
					goto l21
				}
				add(ruleQueryFrom, position22)
			}
			return true
		l21:
			position, tokenIndex = position21, tokenIndex21
			return false
		},
		/* 4 QueryTo <- <('t' 'o' Space CMP_EQ Space Expr Action3)> */
		func() bool {
			position23, tokenIndex23 := position, tokenIndex
			{
				position24 := position
				if buffer[position] != rune('t') {
					goto l23
				}
				position++
				if buffer[position] != rune('o') {
					goto l23
				}
				position++
				if !_rules[ruleSpace]() {
					goto l23
				}
				if !_rules[ruleCMP_EQ]() {
					goto l23
				}
				if !_rules[ruleSpace]() {
					goto l23
				}
				if !_rules[ruleExpr]() {
					goto l23
				}
				if !_rules[ruleAction3]() {
					goto l23
				}
				add(ruleQueryTo, position24)
			}
			return true
		l23:
			position, tokenIndex = position23, tokenIndex23
			return false
		},
		/* 5 QueryMachineContext <- <('m' 'a' 'c' 'h' 'i' 'n' 'e' Space ((CMP_EQ Space Expr Action4) / (CMP_NOTEQ Space Expr Action5) / (SET_IN Space Expr Action6) / (SET_NOTIN Space Expr Action7)))> */
		func() bool {
			position25, tokenIndex25 := position, tokenIndex
			{
				position26 := position
				if buffer[position] != rune('m') {
					goto l25
				}
				position++
				if buffer[position] != rune('a') {
					goto l25
				}
				position++
				if buffer[position] != rune('c') {
					goto l25
				}
				position++
				if buffer[position] != rune('h') {
					goto l25
				}
				position++
				if buffer[position] != rune('i') {
					goto l25
				}
				position++
				if buffer[position] != rune('n') {
					goto l25
				}
				position++
				if buffer[position] != rune('e') {
					goto l25
				}
				position++
				if !_rules[ruleSpace]() {
					goto l25
				}
				{
					position27, tokenIndex27 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l28
					}
					if !_rules[ruleSpace]() {
						goto l28
					}
					if !_rules[ruleExpr]() {
						goto l28
					}
					if !_rules[ruleAction4]() {
						goto l28
					}
					goto l27
				l28:
					position, tokenIndex = position27, tokenIndex27
					if !_rules[ruleCMP_NOTEQ]() {
						goto l29
					}
					if !_rules[ruleSpace]() {
						goto l29
					}
					if !_rules[ruleExpr]() {
						goto l29
					}
					if !_rules[ruleAction5]() {
						goto l29
					}
					goto l27
				l29:
					position, tokenIndex = position27, tokenIndex27
					if !_rules[ruleSET_IN]() {
						goto l30
					}
					if !_rules[ruleSpace]() {
						goto l30
					}
					if !_rules[ruleExpr]() {
						goto l30
					}
					if !_rules[ruleAction6]() {
						goto l30
					}
					goto l27
				l30:
					position, tokenIndex = position27, tokenIndex27
					if !_rules[ruleSET_NOTIN]() {
						goto l25
					}
					if !_rules[ruleSpace]() {
						goto l25
					}
					if !_rules[ruleExpr]() {
						goto l25
					}
					if !_rules[ruleAction7]() {
						goto l25
					}
				}
			l27:
				add(ruleQueryMachineContext, position26)
			}
			return true
		l25:
			position, tokenIndex = position25, tokenIndex25
			return false
		},
		/* 6 QuerySessionContext <- <('s' 'e' 's' 's' 'i' 'o' 'n' Space ((CMP_EQ Space Expr Action8) / (CMP_NOTEQ Space Expr Action9) / (SET_IN Space Expr Action10) / (SET_NOTIN Space Expr Action11)))> */
		func() bool {
			position31, tokenIndex31 := position, tokenIndex
			{
				position32 := position
				if buffer[position] != rune('s') {
					goto l31
				}
				position++
				if buffer[position] != rune('e') {
					goto l31
				}
				position++
				if buffer[position] != rune('s') {
					goto l31
				}
				position++
				if buffer[position] != rune('s') {
					goto l31
				}
				position++
				if buffer[position] != rune('i') {
					goto l31
				}
				position++
				if buffer[position] != rune('o') {
					goto l31
				}
				position++
				if buffer[position] != rune('n') {
					goto l31
				}
				position++
				if !_rules[ruleSpace]() {
					goto l31
				}
				{
					position33, tokenIndex33 := position, tokenIndex
					if !_rules[ruleCMP_EQ]() {
						goto l34
					}
					if !_rules[ruleSpace]() {
						goto l34
					}
					if !_rules[ruleExpr]() {
						goto l34
					}
					if !_rules[ruleAction8]() {
						goto l34
					}
					goto l33
				l34:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[ruleCMP_NOTEQ]() {
						goto l35
					}
					if !_rules[ruleSpace]() {
						goto l35
					}
					if !_rules[ruleExpr]() {
						goto l35
					}
					if !_rules[ruleAction9]() {
						goto l35
					}
					goto l33
				l35:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[ruleSET_IN]() {
						goto l36
					}
					if !_rules[ruleSpace]() {
						goto l36
					}
					if !_rules[ruleExpr]() {
						goto l36
					}
					if !_rules[ruleAction10]() {
						goto l36
					}
					goto l33
				l36:
					position, tokenIndex = position33, tokenIndex33
					if !_rules[ruleSET_NOTIN]() {
						goto l31
					}
					if !_rules[ruleSpace]() {
						goto l31
					}
					if !_rules[ruleExpr]() {
						goto l31
					}
					if !_rules[ruleAction11]() {
						goto l31
					}
				}
			l33:
				add(ruleQuerySessionContext, position32)
			}
			return true
		l31:
			position, tokenIndex = position31, tokenIndex31
			return false
		},
		/* 7 Statements <- <(Statement (Space PIPE Space Statement)*)> */
		func() bool {
			position37, tokenIndex37 := position, tokenIndex
			{
				position38 := position
				if !_rules[ruleStatement]() {
					goto l37
				}
			l39:
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l40
					}
					if !_rules[rulePIPE]() {
						goto l40
					}
					if !_rules[ruleSpace]() {
						goto l40
					}
					if !_rules[ruleStatement]() {
						goto l40
					}
					goto l39
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
				add(ruleStatements, position38)
			}
			return true
		l37:
			position, tokenIndex = position37, tokenIndex37
			return false
		},
		/* 8 Statement <- <(((('f' 'i' 'l' 't' 'e' 'r') / ('w' 'h' 'e' 'r' 'e')) MustSpace FilterOperator Action12) / ('s' 'u' 'm' 'm' 'a' 'r' 'i' 'z' 'e' MustSpace SummarizeOperator Action13) / ('p' 'r' 'o' 'j' 'e' 'c' 't' MustSpace ProjectOperator Action14))> */
		func() bool {
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				{
					position43, tokenIndex43 := position, tokenIndex
					{
						position45, tokenIndex45 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l46
						}
						position++
						if buffer[position] != rune('i') {
							goto l46
						}
						position++
						if buffer[position] != rune('l') {
							goto l46
						}
						position++
						if buffer[position] != rune('t') {
							goto l46
						}
						position++
						if buffer[position] != rune('e') {
							goto l46
						}
						position++
						if buffer[position] != rune('r') {
							goto l46
						}
						position++
						goto l45
					l46:
						position, tokenIndex = position45, tokenIndex45
						if buffer[position] != rune('w') {
							goto l44
						}
						position++
						if buffer[position] != rune('h') {
							goto l44
						}
						position++
						if buffer[position] != rune('e') {
							goto l44
						}
						position++
						if buffer[position] != rune('r') {
							goto l44
						}
						position++
						if buffer[position] != rune('e') {
							goto l44
						}
						position++
					}
				l45:
					if !_rules[ruleMustSpace]() {
						goto l44
					}
					if !_rules[ruleFilterOperator]() {
						goto l44
					}
					if !_rules[ruleAction12]() {
						goto l44
					}
					goto l43
				l44:
					position, tokenIndex = position43, tokenIndex43
					if buffer[position] != rune('s') {
						goto l47
					}
					position++
					if buffer[position] != rune('u') {
						goto l47
					}
					position++
					if buffer[position] != rune('m') {
						goto l47
					}
					position++
					if buffer[position] != rune('m') {
						goto l47
					}
					position++
					if buffer[position] != rune('a') {
						goto l47
					}
					position++
					if buffer[position] != rune('r') {
						goto l47
					}
					position++
					if buffer[position] != rune('i') {
						goto l47
					}
					position++
					if buffer[position] != rune('z') {
						goto l47
					}
					position++
					if buffer[position] != rune('e') {
						goto l47
					}
					position++
					if !_rules[ruleMustSpace]() {
						goto l47
					}
					if !_rules[ruleSummarizeOperator]() {
						goto l47
					}
					if !_rules[ruleAction13]() {
						goto l47
					}
					goto l43
				l47:
					position, tokenIndex = position43, tokenIndex43
					if buffer[position] != rune('p') {
						goto l41
					}
					position++
					if buffer[position] != rune('r') {
						goto l41
					}
					position++
					if buffer[position] != rune('o') {
						goto l41
					}
					position++
					if buffer[position] != rune('j') {
						goto l41
					}
					position++
					if buffer[position] != rune('e') {
						goto l41
					}
					position++
					if buffer[position] != rune('c') {
						goto l41
					}
					position++
					if buffer[position] != rune('t') {
						goto l41
					}
					position++
					if !_rules[ruleMustSpace]() {
						goto l41
					}
					if !_rules[ruleProjectOperator]() {
						goto l41
					}
					if !_rules[ruleAction14]() {
						goto l41
					}
				}
			l43:
				add(ruleStatement, position42)
			}
			return true
		l41:
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 9 RenderStatement <- <(Space PIPE Space ('r' 'e' 'n' 'd' 'e' 'r') MustSpace RenderSplitOperator Action15)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleSpace]() {
					goto l48
				}
				if !_rules[rulePIPE]() {
					goto l48
				}
				if !_rules[ruleSpace]() {
					goto l48
				}
				if buffer[position] != rune('r') {
					goto l48
				}
				position++
				if buffer[position] != rune('e') {
					goto l48
				}
				position++
				if buffer[position] != rune('n') {
					goto l48
				}
				position++
				if buffer[position] != rune('d') {
					goto l48
				}
				position++
				if buffer[position] != rune('e') {
					goto l48
				}
				position++
				if buffer[position] != rune('r') {
					goto l48
				}
				position++
				if !_rules[ruleMustSpace]() {
					goto l48
				}
				if !_rules[ruleRenderSplitOperator]() {
					goto l48
				}
				if !_rules[ruleAction15]() {
					goto l48
				}
				add(ruleRenderStatement, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 10 FilterOperator <- <(Expr Action16)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleExpr]() {
					goto l50
				}
				if !_rules[ruleAction16]() {
					goto l50
				}
				add(ruleFilterOperator, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 11 SummarizeOperator <- <(Action17 SummarizeParameters SummarizeByGroupExpressions?)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleAction17]() {
					goto l52
				}
				if !_rules[ruleSummarizeParameters]() {
					goto l52
				}
				{
					position54, tokenIndex54 := position, tokenIndex
					if !_rules[ruleSummarizeByGroupExpressions]() {
						goto l54
					}
					goto l55
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
			l55:
				add(ruleSummarizeOperator, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 SummarizeParameters <- <(SummarizeParameter (Space ',' Space SummarizeParameter)* Space)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleSummarizeParameter]() {
					goto l56
				}
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l59
					}
					if buffer[position] != rune(',') {
						goto l59
					}
					position++
					if !_rules[ruleSpace]() {
						goto l59
					}
					if !_rules[ruleSummarizeParameter]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				if !_rules[ruleSpace]() {
					goto l56
				}
				add(ruleSummarizeParameters, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 SummarizeParameter <- <((Identifier Action18 (Space '=' Space FuncCall) Action19) / (FuncCall Action20))> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				{
					position62, tokenIndex62 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l63
					}
					if !_rules[ruleAction18]() {
						goto l63
					}
					if !_rules[ruleSpace]() {
						goto l63
					}
					if buffer[position] != rune('=') {
						goto l63
					}
					position++
					if !_rules[ruleSpace]() {
						goto l63
					}
					if !_rules[ruleFuncCall]() {
						goto l63
					}
					if !_rules[ruleAction19]() {
						goto l63
					}
					goto l62
				l63:
					position, tokenIndex = position62, tokenIndex62
					if !_rules[ruleFuncCall]() {
						goto l60
					}
					if !_rules[ruleAction20]() {
						goto l60
					}
				}
			l62:
				add(ruleSummarizeParameter, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 SummarizeByGroupExpressions <- <('b' 'y' MustSpace SummarizeByGroupExpression (Space ',' Space SummarizeByGroupExpression)* Space)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if buffer[position] != rune('b') {
					goto l64
				}
				position++
				if buffer[position] != rune('y') {
					goto l64
				}
				position++
				if !_rules[ruleMustSpace]() {
					goto l64
				}
				if !_rules[ruleSummarizeByGroupExpression]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l67
					}
					if buffer[position] != rune(',') {
						goto l67
					}
					position++
					if !_rules[ruleSpace]() {
						goto l67
					}
					if !_rules[ruleSummarizeByGroupExpression]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				if !_rules[ruleSpace]() {
					goto l64
				}
				add(ruleSummarizeByGroupExpressions, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 SummarizeByGroupExpression <- <((Identifier Action21 (Space '=' Space Expr) Action22) / (Expr Action23))> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				{
					position70, tokenIndex70 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l71
					}
					if !_rules[ruleAction21]() {
						goto l71
					}
					if !_rules[ruleSpace]() {
						goto l71
					}
					if buffer[position] != rune('=') {
						goto l71
					}
					position++
					if !_rules[ruleSpace]() {
						goto l71
					}
					if !_rules[ruleExpr]() {
						goto l71
					}
					if !_rules[ruleAction22]() {
						goto l71
					}
					goto l70
				l71:
					position, tokenIndex = position70, tokenIndex70
					if !_rules[ruleExpr]() {
						goto l68
					}
					if !_rules[ruleAction23]() {
						goto l68
					}
				}
			l70:
				add(ruleSummarizeByGroupExpression, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 16 ProjectOperator <- <(Action24 ProjectArg (Space ',' Space ProjectArg)* Space)> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				if !_rules[ruleAction24]() {
					goto l72
				}
				if !_rules[ruleProjectArg]() {
					goto l72
				}
			l74:
				{
					position75, tokenIndex75 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l75
					}
					if buffer[position] != rune(',') {
						goto l75
					}
					position++
					if !_rules[ruleSpace]() {
						goto l75
					}
					if !_rules[ruleProjectArg]() {
						goto l75
					}
					goto l74
				l75:
					position, tokenIndex = position75, tokenIndex75
				}
				if !_rules[ruleSpace]() {
					goto l72
				}
				add(ruleProjectOperator, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 17 ProjectArg <- <(Identifier Action25 (Space '=' Space Expr)? Action26)> */
		func() bool {
			position76, tokenIndex76 := position, tokenIndex
			{
				position77 := position
				if !_rules[ruleIdentifier]() {
					goto l76
				}
				if !_rules[ruleAction25]() {
					goto l76
				}
				{
					position78, tokenIndex78 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l78
					}
					if buffer[position] != rune('=') {
						goto l78
					}
					position++
					if !_rules[ruleSpace]() {
						goto l78
					}
					if !_rules[ruleExpr]() {
						goto l78
					}
					goto l79
				l78:
					position, tokenIndex = position78, tokenIndex78
				}
			l79:
				if !_rules[ruleAction26]() {
					goto l76
				}
				add(ruleProjectArg, position77)
			}
			return true
		l76:
			position, tokenIndex = position76, tokenIndex76
			return false
		},
		/* 18 RenderSplitOperator <- <('s' 'p' 'l' 'i' 't' Action27 MustSpace RenderSplitByOperator)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				if buffer[position] != rune('s') {
					goto l80
				}
				position++
				if buffer[position] != rune('p') {
					goto l80
				}
				position++
				if buffer[position] != rune('l') {
					goto l80
				}
				position++
				if buffer[position] != rune('i') {
					goto l80
				}
				position++
				if buffer[position] != rune('t') {
					goto l80
				}
				position++
				if !_rules[ruleAction27]() {
					goto l80
				}
				if !_rules[ruleMustSpace]() {
					goto l80
				}
				if !_rules[ruleRenderSplitByOperator]() {
					goto l80
				}
				add(ruleRenderSplitOperator, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 19 RenderSplitByOperator <- <('b' 'y' MustSpace RenderSplitByOperatorArg (Space ',' Space RenderSplitByOperatorArg)* Space)> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				if buffer[position] != rune('b') {
					goto l82
				}
				position++
				if buffer[position] != rune('y') {
					goto l82
				}
				position++
				if !_rules[ruleMustSpace]() {
					goto l82
				}
				if !_rules[ruleRenderSplitByOperatorArg]() {
					goto l82
				}
			l84:
				{
					position85, tokenIndex85 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l85
					}
					if buffer[position] != rune(',') {
						goto l85
					}
					position++
					if !_rules[ruleSpace]() {
						goto l85
					}
					if !_rules[ruleRenderSplitByOperatorArg]() {
						goto l85
					}
					goto l84
				l85:
					position, tokenIndex = position85, tokenIndex85
				}
				if !_rules[ruleSpace]() {
					goto l82
				}
				add(ruleRenderSplitByOperator, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 20 RenderSplitByOperatorArg <- <(Expr Action28)> */
		func() bool {
			position86, tokenIndex86 := position, tokenIndex
			{
				position87 := position
				if !_rules[ruleExpr]() {
					goto l86
				}
				if !_rules[ruleAction28]() {
					goto l86
				}
				add(ruleRenderSplitByOperatorArg, position87)
			}
			return true
		l86:
			position, tokenIndex = position86, tokenIndex86
			return false
		},
		/* 21 Expr <- <(Expr1 ((Space NUM_ADD Expr1 Space Action29) / (Space NUM_SUB Expr1 Space Action30))*)> */
		func() bool {
			position88, tokenIndex88 := position, tokenIndex
			{
				position89 := position
				if !_rules[ruleExpr1]() {
					goto l88
				}
			l90:
				{
					position91, tokenIndex91 := position, tokenIndex
					{
						position92, tokenIndex92 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l93
						}
						if !_rules[ruleNUM_ADD]() {
							goto l93
						}
						if !_rules[ruleExpr1]() {
							goto l93
						}
						if !_rules[ruleSpace]() {
							goto l93
						}
						if !_rules[ruleAction29]() {
							goto l93
						}
						goto l92
					l93:
						position, tokenIndex = position92, tokenIndex92
						if !_rules[ruleSpace]() {
							goto l91
						}
						if !_rules[ruleNUM_SUB]() {
							goto l91
						}
						if !_rules[ruleExpr1]() {
							goto l91
						}
						if !_rules[ruleSpace]() {
							goto l91
						}
						if !_rules[ruleAction30]() {
							goto l91
						}
					}
				l92:
					goto l90
				l91:
					position, tokenIndex = position91, tokenIndex91
				}
				add(ruleExpr, position89)
			}
			return true
		l88:
			position, tokenIndex = position88, tokenIndex88
			return false
		},
		/* 22 Expr1 <- <(Expr2 ((Space NUM_MUL Expr2 Space Action31) / (Space NUM_DIV Expr2 Space Action32))*)> */
		func() bool {
			position94, tokenIndex94 := position, tokenIndex
			{
				position95 := position
				if !_rules[ruleExpr2]() {
					goto l94
				}
			l96:
				{
					position97, tokenIndex97 := position, tokenIndex
					{
						position98, tokenIndex98 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l99
						}
						if !_rules[ruleNUM_MUL]() {
							goto l99
						}
						if !_rules[ruleExpr2]() {
							goto l99
						}
						if !_rules[ruleSpace]() {
							goto l99
						}
						if !_rules[ruleAction31]() {
							goto l99
						}
						goto l98
					l99:
						position, tokenIndex = position98, tokenIndex98
						if !_rules[ruleSpace]() {
							goto l97
						}
						if !_rules[ruleNUM_DIV]() {
							goto l97
						}
						if !_rules[ruleExpr2]() {
							goto l97
						}
						if !_rules[ruleSpace]() {
							goto l97
						}
						if !_rules[ruleAction32]() {
							goto l97
						}
					}
				l98:
					goto l96
				l97:
					position, tokenIndex = position97, tokenIndex97
				}
				add(ruleExpr1, position95)
			}
			return true
		l94:
			position, tokenIndex = position94, tokenIndex94
			return false
		},
		/* 23 Expr2 <- <(Expr3 ((Space LOG_AND Expr3 Space Action33) / (Space LOG_OR Expr3 Space Action34))*)> */
		func() bool {
			position100, tokenIndex100 := position, tokenIndex
			{
				position101 := position
				if !_rules[ruleExpr3]() {
					goto l100
				}
			l102:
				{
					position103, tokenIndex103 := position, tokenIndex
					{
						position104, tokenIndex104 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l105
						}
						if !_rules[ruleLOG_AND]() {
							goto l105
						}
						if !_rules[ruleExpr3]() {
							goto l105
						}
						if !_rules[ruleSpace]() {
							goto l105
						}
						if !_rules[ruleAction33]() {
							goto l105
						}
						goto l104
					l105:
						position, tokenIndex = position104, tokenIndex104
						if !_rules[ruleSpace]() {
							goto l103
						}
						if !_rules[ruleLOG_OR]() {
							goto l103
						}
						if !_rules[ruleExpr3]() {
							goto l103
						}
						if !_rules[ruleSpace]() {
							goto l103
						}
						if !_rules[ruleAction34]() {
							goto l103
						}
					}
				l104:
					goto l102
				l103:
					position, tokenIndex = position103, tokenIndex103
				}
				add(ruleExpr2, position101)
			}
			return true
		l100:
			position, tokenIndex = position100, tokenIndex100
			return false
		},
		/* 24 Expr3 <- <(Expr4 ((Space CMP_EQ Expr4 Action35) / (Space CMP_NOTEQ Expr4 Action36) / (Space CMP_GT Expr4 Action37) / (Space CMP_GTE Expr4 Action38) / (Space CMP_LT Expr4 Action39) / (Space CMP_LTE Expr4 Action40) / (Space SET_IN Expr4 Action41) / (Space SET_NOTIN Expr4 Action42))*)> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				if !_rules[ruleExpr4]() {
					goto l106
				}
			l108:
				{
					position109, tokenIndex109 := position, tokenIndex
					{
						position110, tokenIndex110 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l111
						}
						if !_rules[ruleCMP_EQ]() {
							goto l111
						}
						if !_rules[ruleExpr4]() {
							goto l111
						}
						if !_rules[ruleAction35]() {
							goto l111
						}
						goto l110
					l111:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l112
						}
						if !_rules[ruleCMP_NOTEQ]() {
							goto l112
						}
						if !_rules[ruleExpr4]() {
							goto l112
						}
						if !_rules[ruleAction36]() {
							goto l112
						}
						goto l110
					l112:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l113
						}
						if !_rules[ruleCMP_GT]() {
							goto l113
						}
						if !_rules[ruleExpr4]() {
							goto l113
						}
						if !_rules[ruleAction37]() {
							goto l113
						}
						goto l110
					l113:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l114
						}
						if !_rules[ruleCMP_GTE]() {
							goto l114
						}
						if !_rules[ruleExpr4]() {
							goto l114
						}
						if !_rules[ruleAction38]() {
							goto l114
						}
						goto l110
					l114:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l115
						}
						if !_rules[ruleCMP_LT]() {
							goto l115
						}
						if !_rules[ruleExpr4]() {
							goto l115
						}
						if !_rules[ruleAction39]() {
							goto l115
						}
						goto l110
					l115:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l116
						}
						if !_rules[ruleCMP_LTE]() {
							goto l116
						}
						if !_rules[ruleExpr4]() {
							goto l116
						}
						if !_rules[ruleAction40]() {
							goto l116
						}
						goto l110
					l116:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l117
						}
						if !_rules[ruleSET_IN]() {
							goto l117
						}
						if !_rules[ruleExpr4]() {
							goto l117
						}
						if !_rules[ruleAction41]() {
							goto l117
						}
						goto l110
					l117:
						position, tokenIndex = position110, tokenIndex110
						if !_rules[ruleSpace]() {
							goto l109
						}
						if !_rules[ruleSET_NOTIN]() {
							goto l109
						}
						if !_rules[ruleExpr4]() {
							goto l109
						}
						if !_rules[ruleAction42]() {
							goto l109
						}
					}
				l110:
					goto l108
				l109:
					position, tokenIndex = position109, tokenIndex109
				}
				add(ruleExpr3, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 25 Expr4 <- <(Expr5 ((Space L_BRACKET Expr5 R_BRACKET Action43) / (Space DOT <SelectorId> Action44))*)> */
		func() bool {
			position118, tokenIndex118 := position, tokenIndex
			{
				position119 := position
				if !_rules[ruleExpr5]() {
					goto l118
				}
			l120:
				{
					position121, tokenIndex121 := position, tokenIndex
					{
						position122, tokenIndex122 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l123
						}
						if !_rules[ruleL_BRACKET]() {
							goto l123
						}
						if !_rules[ruleExpr5]() {
							goto l123
						}
						if !_rules[ruleR_BRACKET]() {
							goto l123
						}
						if !_rules[ruleAction43]() {
							goto l123
						}
						goto l122
					l123:
						position, tokenIndex = position122, tokenIndex122
						if !_rules[ruleSpace]() {
							goto l121
						}
						if !_rules[ruleDOT]() {
							goto l121
						}
						{
							position124 := position
							if !_rules[ruleSelectorId]() {
								goto l121
							}
							add(rulePegText, position124)
						}
						if !_rules[ruleAction44]() {
							goto l121
						}
					}
				l122:
					goto l120
				l121:
					position, tokenIndex = position121, tokenIndex121
				}
				add(ruleExpr4, position119)
			}
			return true
		l118:
			position, tokenIndex = position118, tokenIndex118
			return false
		},
		/* 26 Expr5 <- <((L_PARENS Expr R_PARENS Space) / (NOT Literal Space Action45) / (NOT L_PARENS Expr R_PARENS Space Action46) / (NEG Literal Space Action47) / (NEG L_PARENS Expr R_PARENS Space Action48) / (Literal Space Action49) / (FuncCall Space Action50) / (Identifier Space))> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127, tokenIndex127 := position, tokenIndex
					if !_rules[ruleL_PARENS]() {
						goto l128
					}
					if !_rules[ruleExpr]() {
						goto l128
					}
					if !_rules[ruleR_PARENS]() {
						goto l128
					}
					if !_rules[ruleSpace]() {
						goto l128
					}
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleNOT]() {
						goto l129
					}
					if !_rules[ruleLiteral]() {
						goto l129
					}
					if !_rules[ruleSpace]() {
						goto l129
					}
					if !_rules[ruleAction45]() {
						goto l129
					}
					goto l127
				l129:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleNOT]() {
						goto l130
					}
					if !_rules[ruleL_PARENS]() {
						goto l130
					}
					if !_rules[ruleExpr]() {
						goto l130
					}
					if !_rules[ruleR_PARENS]() {
						goto l130
					}
					if !_rules[ruleSpace]() {
						goto l130
					}
					if !_rules[ruleAction46]() {
						goto l130
					}
					goto l127
				l130:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleNEG]() {
						goto l131
					}
					if !_rules[ruleLiteral]() {
						goto l131
					}
					if !_rules[ruleSpace]() {
						goto l131
					}
					if !_rules[ruleAction47]() {
						goto l131
					}
					goto l127
				l131:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleNEG]() {
						goto l132
					}
					if !_rules[ruleL_PARENS]() {
						goto l132
					}
					if !_rules[ruleExpr]() {
						goto l132
					}
					if !_rules[ruleR_PARENS]() {
						goto l132
					}
					if !_rules[ruleSpace]() {
						goto l132
					}
					if !_rules[ruleAction48]() {
						goto l132
					}
					goto l127
				l132:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleLiteral]() {
						goto l133
					}
					if !_rules[ruleSpace]() {
						goto l133
					}
					if !_rules[ruleAction49]() {
						goto l133
					}
					goto l127
				l133:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleFuncCall]() {
						goto l134
					}
					if !_rules[ruleSpace]() {
						goto l134
					}
					if !_rules[ruleAction50]() {
						goto l134
					}
					goto l127
				l134:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleIdentifier]() {
						goto l125
					}
					if !_rules[ruleSpace]() {
						goto l125
					}
				}
			l127:
				add(ruleExpr5, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 27 Literal <- <((String Action51) / (('d' 'u' 'r' ':')? Duration Action52) / (('t' 's' ':')? Timestamp Action53) / (F64 Action54) / (I64 Action55) / (Bool Action56) / (Array Action57) / (Object Action58))> */
		func() bool {
			position135, tokenIndex135 := position, tokenIndex
			{
				position136 := position
				{
					position137, tokenIndex137 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l138
					}
					if !_rules[ruleAction51]() {
						goto l138
					}
					goto l137
				l138:
					position, tokenIndex = position137, tokenIndex137
					{
						position140, tokenIndex140 := position, tokenIndex
						if buffer[position] != rune('d') {
							goto l140
						}
						position++
						if buffer[position] != rune('u') {
							goto l140
						}
						position++
						if buffer[position] != rune('r') {
							goto l140
						}
						position++
						if buffer[position] != rune(':') {
							goto l140
						}
						position++
						goto l141
					l140:
						position, tokenIndex = position140, tokenIndex140
					}
				l141:
					if !_rules[ruleDuration]() {
						goto l139
					}
					if !_rules[ruleAction52]() {
						goto l139
					}
					goto l137
				l139:
					position, tokenIndex = position137, tokenIndex137
					{
						position143, tokenIndex143 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l143
						}
						position++
						if buffer[position] != rune('s') {
							goto l143
						}
						position++
						if buffer[position] != rune(':') {
							goto l143
						}
						position++
						goto l144
					l143:
						position, tokenIndex = position143, tokenIndex143
					}
				l144:
					if !_rules[ruleTimestamp]() {
						goto l142
					}
					if !_rules[ruleAction53]() {
						goto l142
					}
					goto l137
				l142:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleF64]() {
						goto l145
					}
					if !_rules[ruleAction54]() {
						goto l145
					}
					goto l137
				l145:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleI64]() {
						goto l146
					}
					if !_rules[ruleAction55]() {
						goto l146
					}
					goto l137
				l146:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleBool]() {
						goto l147
					}
					if !_rules[ruleAction56]() {
						goto l147
					}
					goto l137
				l147:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleArray]() {
						goto l148
					}
					if !_rules[ruleAction57]() {
						goto l148
					}
					goto l137
				l148:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleObject]() {
						goto l135
					}
					if !_rules[ruleAction58]() {
						goto l135
					}
				}
			l137:
				add(ruleLiteral, position136)
			}
			return true
		l135:
			position, tokenIndex = position135, tokenIndex135
			return false
		},
		/* 28 FuncCall <- <(Action59 FuncName '(' FuncArgs? ')' Space)> */
		func() bool {
			position149, tokenIndex149 := position, tokenIndex
			{
				position150 := position
				if !_rules[ruleAction59]() {
					goto l149
				}
				if !_rules[ruleFuncName]() {
					goto l149
				}
				if buffer[position] != rune('(') {
					goto l149
				}
				position++
				{
					position151, tokenIndex151 := position, tokenIndex
					if !_rules[ruleFuncArgs]() {
						goto l151
					}
					goto l152
				l151:
					position, tokenIndex = position151, tokenIndex151
				}
			l152:
				if buffer[position] != rune(')') {
					goto l149
				}
				position++
				if !_rules[ruleSpace]() {
					goto l149
				}
				add(ruleFuncCall, position150)
			}
			return true
		l149:
			position, tokenIndex = position149, tokenIndex149
			return false
		},
		/* 29 FuncName <- <(!ReservedKeyword <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / '_' / [0-9])*)> Action60)> */
		func() bool {
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				{
					position155, tokenIndex155 := position, tokenIndex
					if !_rules[ruleReservedKeyword]() {
						goto l155
					}
					goto l153
				l155:
					position, tokenIndex = position155, tokenIndex155
				}
				{
					position156 := position
					{
						position157, tokenIndex157 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l158
						}
						position++
						goto l157
					l158:
						position, tokenIndex = position157, tokenIndex157
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l159
						}
						position++
						goto l157
					l159:
						position, tokenIndex = position157, tokenIndex157
						if buffer[position] != rune('_') {
							goto l153
						}
						position++
					}
				l157:
				l160:
					{
						position161, tokenIndex161 := position, tokenIndex
						{
							position162, tokenIndex162 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l163
							}
							position++
							goto l162
						l163:
							position, tokenIndex = position162, tokenIndex162
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l164
							}
							position++
							goto l162
						l164:
							position, tokenIndex = position162, tokenIndex162
							if buffer[position] != rune('_') {
								goto l165
							}
							position++
							goto l162
						l165:
							position, tokenIndex = position162, tokenIndex162
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l161
							}
							position++
						}
					l162:
						goto l160
					l161:
						position, tokenIndex = position161, tokenIndex161
					}
					add(rulePegText, position156)
				}
				if !_rules[ruleAction60]() {
					goto l153
				}
				add(ruleFuncName, position154)
			}
			return true
		l153:
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 30 FuncArgs <- <(FuncArg (Space ',' Space FuncArg)* Space)> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				if !_rules[ruleFuncArg]() {
					goto l166
				}
			l168:
				{
					position169, tokenIndex169 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l169
					}
					if buffer[position] != rune(',') {
						goto l169
					}
					position++
					if !_rules[ruleSpace]() {
						goto l169
					}
					if !_rules[ruleFuncArg]() {
						goto l169
					}
					goto l168
				l169:
					position, tokenIndex = position169, tokenIndex169
				}
				if !_rules[ruleSpace]() {
					goto l166
				}
				add(ruleFuncArgs, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 31 FuncArg <- <(Expr Action61)> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				if !_rules[ruleExpr]() {
					goto l170
				}
				if !_rules[ruleAction61]() {
					goto l170
				}
				add(ruleFuncArg, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 32 Identifier <- <(<(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> Action62)> */
		func() bool {
			position172, tokenIndex172 := position, tokenIndex
			{
				position173 := position
				{
					position174 := position
					{
						position175, tokenIndex175 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l176
						}
						position++
						goto l175
					l176:
						position, tokenIndex = position175, tokenIndex175
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l177
						}
						position++
						goto l175
					l177:
						position, tokenIndex = position175, tokenIndex175
						if buffer[position] != rune('_') {
							goto l172
						}
						position++
					}
				l175:
				l178:
					{
						position179, tokenIndex179 := position, tokenIndex
						{
							position180, tokenIndex180 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l181
							}
							position++
							goto l180
						l181:
							position, tokenIndex = position180, tokenIndex180
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l182
							}
							position++
							goto l180
						l182:
							position, tokenIndex = position180, tokenIndex180
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l183
							}
							position++
							goto l180
						l183:
							position, tokenIndex = position180, tokenIndex180
							if buffer[position] != rune('_') {
								goto l179
							}
							position++
						}
					l180:
						goto l178
					l179:
						position, tokenIndex = position179, tokenIndex179
					}
					add(rulePegText, position174)
				}
				if !_rules[ruleAction62]() {
					goto l172
				}
				add(ruleIdentifier, position173)
			}
			return true
		l172:
			position, tokenIndex = position172, tokenIndex172
			return false
		},
		/* 33 String <- <(<('"' StringChar* '"')> Action63)> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				{
					position186 := position
					if buffer[position] != rune('"') {
						goto l184
					}
					position++
				l187:
					{
						position188, tokenIndex188 := position, tokenIndex
						if !_rules[ruleStringChar]() {
							goto l188
						}
						goto l187
					l188:
						position, tokenIndex = position188, tokenIndex188
					}
					if buffer[position] != rune('"') {
						goto l184
					}
					position++
					add(rulePegText, position186)
				}
				if !_rules[ruleAction63]() {
					goto l184
				}
				add(ruleString, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 34 SelectorId <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position189, tokenIndex189 := position, tokenIndex
			{
				position190 := position
				{
					position191, tokenIndex191 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l192
					}
					position++
					goto l191
				l192:
					position, tokenIndex = position191, tokenIndex191
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l193
					}
					position++
					goto l191
				l193:
					position, tokenIndex = position191, tokenIndex191
					if buffer[position] != rune('_') {
						goto l189
					}
					position++
				}
			l191:
			l194:
				{
					position195, tokenIndex195 := position, tokenIndex
					{
						position196, tokenIndex196 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l197
						}
						position++
						goto l196
					l197:
						position, tokenIndex = position196, tokenIndex196
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l198
						}
						position++
						goto l196
					l198:
						position, tokenIndex = position196, tokenIndex196
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l199
						}
						position++
						goto l196
					l199:
						position, tokenIndex = position196, tokenIndex196
						if buffer[position] != rune('_') {
							goto l195
						}
						position++
					}
				l196:
					goto l194
				l195:
					position, tokenIndex = position195, tokenIndex195
				}
				add(ruleSelectorId, position190)
			}
			return true
		l189:
			position, tokenIndex = position189, tokenIndex189
			return false
		},
		/* 35 F64 <- <((<(Digits '.' Digits? Exponent?)> Action64) / (<('.' Digits Exponent?)> Action65) / (<(Digits Exponent)> Action66))> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				{
					position202, tokenIndex202 := position, tokenIndex
					{
						position204 := position
						if !_rules[ruleDigits]() {
							goto l203
						}
						if buffer[position] != rune('.') {
							goto l203
						}
						position++
						{
							position205, tokenIndex205 := position, tokenIndex
							if !_rules[ruleDigits]() {
								goto l205
							}
							goto l206
						l205:
							position, tokenIndex = position205, tokenIndex205
						}
					l206:
						{
							position207, tokenIndex207 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l207
							}
							goto l208
						l207:
							position, tokenIndex = position207, tokenIndex207
						}
					l208:
						add(rulePegText, position204)
					}
					if !_rules[ruleAction64]() {
						goto l203
					}
					goto l202
				l203:
					position, tokenIndex = position202, tokenIndex202
					{
						position210 := position
						if buffer[position] != rune('.') {
							goto l209
						}
						position++
						if !_rules[ruleDigits]() {
							goto l209
						}
						{
							position211, tokenIndex211 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l211
							}
							goto l212
						l211:
							position, tokenIndex = position211, tokenIndex211
						}
					l212:
						add(rulePegText, position210)
					}
					if !_rules[ruleAction65]() {
						goto l209
					}
					goto l202
				l209:
					position, tokenIndex = position202, tokenIndex202
					{
						position213 := position
						if !_rules[ruleDigits]() {
							goto l200
						}
						if !_rules[ruleExponent]() {
							goto l200
						}
						add(rulePegText, position213)
					}
					if !_rules[ruleAction66]() {
						goto l200
					}
				}
			l202:
				add(ruleF64, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 36 I64 <- <(('0' Action67) / (<([1-9] ('_'* [0-9])*)> Action68))> */
		func() bool {
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				{
					position216, tokenIndex216 := position, tokenIndex
					if buffer[position] != rune('0') {
						goto l217
					}
					position++
					if !_rules[ruleAction67]() {
						goto l217
					}
					goto l216
				l217:
					position, tokenIndex = position216, tokenIndex216
					{
						position218 := position
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l214
						}
						position++
					l219:
						{
							position220, tokenIndex220 := position, tokenIndex
						l221:
							{
								position222, tokenIndex222 := position, tokenIndex
								if buffer[position] != rune('_') {
									goto l222
								}
								position++
								goto l221
							l222:
								position, tokenIndex = position222, tokenIndex222
							}
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l220
							}
							position++
							goto l219
						l220:
							position, tokenIndex = position220, tokenIndex220
						}
						add(rulePegText, position218)
					}
					if !_rules[ruleAction68]() {
						goto l214
					}
				}
			l216:
				add(ruleI64, position215)
			}
			return true
		l214:
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 37 Bool <- <(('t' 'r' 'u' 'e' Action69) / ('f' 'a' 'l' 's' 'e' Action70))> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				{
					position225, tokenIndex225 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l226
					}
					position++
					if buffer[position] != rune('r') {
						goto l226
					}
					position++
					if buffer[position] != rune('u') {
						goto l226
					}
					position++
					if buffer[position] != rune('e') {
						goto l226
					}
					position++
					if !_rules[ruleAction69]() {
						goto l226
					}
					goto l225
				l226:
					position, tokenIndex = position225, tokenIndex225
					if buffer[position] != rune('f') {
						goto l223
					}
					position++
					if buffer[position] != rune('a') {
						goto l223
					}
					position++
					if buffer[position] != rune('l') {
						goto l223
					}
					position++
					if buffer[position] != rune('s') {
						goto l223
					}
					position++
					if buffer[position] != rune('e') {
						goto l223
					}
					position++
					if !_rules[ruleAction70]() {
						goto l223
					}
				}
			l225:
				add(ruleBool, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 38 ReservedKeyword <- <(('l' 'v' 'l') / ('m' 's' 'g') / ('k' 'v') / Bool)> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				{
					position229, tokenIndex229 := position, tokenIndex
					if buffer[position] != rune('l') {
						goto l230
					}
					position++
					if buffer[position] != rune('v') {
						goto l230
					}
					position++
					if buffer[position] != rune('l') {
						goto l230
					}
					position++
					goto l229
				l230:
					position, tokenIndex = position229, tokenIndex229
					if buffer[position] != rune('m') {
						goto l231
					}
					position++
					if buffer[position] != rune('s') {
						goto l231
					}
					position++
					if buffer[position] != rune('g') {
						goto l231
					}
					position++
					goto l229
				l231:
					position, tokenIndex = position229, tokenIndex229
					if buffer[position] != rune('k') {
						goto l232
					}
					position++
					if buffer[position] != rune('v') {
						goto l232
					}
					position++
					goto l229
				l232:
					position, tokenIndex = position229, tokenIndex229
					if !_rules[ruleBool]() {
						goto l227
					}
				}
			l229:
				add(ruleReservedKeyword, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 39 Array <- <(L_BRACKET Action71 (ArrayItem (COMMA ArrayItem)*)? R_BRACKET)> */
		func() bool {
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				if !_rules[ruleL_BRACKET]() {
					goto l233
				}
				if !_rules[ruleAction71]() {
					goto l233
				}
				{
					position235, tokenIndex235 := position, tokenIndex
					if !_rules[ruleArrayItem]() {
						goto l235
					}
				l237:
					{
						position238, tokenIndex238 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l238
						}
						if !_rules[ruleArrayItem]() {
							goto l238
						}
						goto l237
					l238:
						position, tokenIndex = position238, tokenIndex238
					}
					goto l236
				l235:
					position, tokenIndex = position235, tokenIndex235
				}
			l236:
				if !_rules[ruleR_BRACKET]() {
					goto l233
				}
				add(ruleArray, position234)
			}
			return true
		l233:
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 40 ArrayItem <- <(Literal Action72)> */
		func() bool {
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				if !_rules[ruleLiteral]() {
					goto l239
				}
				if !_rules[ruleAction72]() {
					goto l239
				}
				add(ruleArrayItem, position240)
			}
			return true
		l239:
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 41 Object <- <(L_SQUIGGLY Action73 (ObjectItem (COMMA ObjectItem)*)? R_SQUIGGLY)> */
		func() bool {
			position241, tokenIndex241 := position, tokenIndex
			{
				position242 := position
				if !_rules[ruleL_SQUIGGLY]() {
					goto l241
				}
				if !_rules[ruleAction73]() {
					goto l241
				}
				{
					position243, tokenIndex243 := position, tokenIndex
					if !_rules[ruleObjectItem]() {
						goto l243
					}
				l245:
					{
						position246, tokenIndex246 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l246
						}
						if !_rules[ruleObjectItem]() {
							goto l246
						}
						goto l245
					l246:
						position, tokenIndex = position246, tokenIndex246
					}
					goto l244
				l243:
					position, tokenIndex = position243, tokenIndex243
				}
			l244:
				if !_rules[ruleR_SQUIGGLY]() {
					goto l241
				}
				add(ruleObject, position242)
			}
			return true
		l241:
			position, tokenIndex = position241, tokenIndex241
			return false
		},
		/* 42 ObjectItem <- <(ObjectKey COLON Literal Action74)> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				if !_rules[ruleObjectKey]() {
					goto l247
				}
				if !_rules[ruleCOLON]() {
					goto l247
				}
				if !_rules[ruleLiteral]() {
					goto l247
				}
				if !_rules[ruleAction74]() {
					goto l247
				}
				add(ruleObjectItem, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 43 ObjectKey <- <(String Action75)> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				if !_rules[ruleString]() {
					goto l249
				}
				if !_rules[ruleAction75]() {
					goto l249
				}
				add(ruleObjectKey, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 44 Duration <- <((F64 <(('u' 's') / ('µ' 's') / ('m' 's') / 's' / 'm' / 'h')> Action76) / (I64 <(('n' 's') / ('u' 's') / ('µ' 's') / ('m' 's') / 's' / 'm' / 'h')> Action77))> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				{
					position253, tokenIndex253 := position, tokenIndex
					if !_rules[ruleF64]() {
						goto l254
					}
					{
						position255 := position
						{
							position256, tokenIndex256 := position, tokenIndex
							if buffer[position] != rune('u') {
								goto l257
							}
							position++
							if buffer[position] != rune('s') {
								goto l257
							}
							position++
							goto l256
						l257:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('µ') {
								goto l258
							}
							position++
							if buffer[position] != rune('s') {
								goto l258
							}
							position++
							goto l256
						l258:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('m') {
								goto l259
							}
							position++
							if buffer[position] != rune('s') {
								goto l259
							}
							position++
							goto l256
						l259:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('s') {
								goto l260
							}
							position++
							goto l256
						l260:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('m') {
								goto l261
							}
							position++
							goto l256
						l261:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('h') {
								goto l254
							}
							position++
						}
					l256:
						add(rulePegText, position255)
					}
					if !_rules[ruleAction76]() {
						goto l254
					}
					goto l253
				l254:
					position, tokenIndex = position253, tokenIndex253
					if !_rules[ruleI64]() {
						goto l251
					}
					{
						position262 := position
						{
							position263, tokenIndex263 := position, tokenIndex
							if buffer[position] != rune('n') {
								goto l264
							}
							position++
							if buffer[position] != rune('s') {
								goto l264
							}
							position++
							goto l263
						l264:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('u') {
								goto l265
							}
							position++
							if buffer[position] != rune('s') {
								goto l265
							}
							position++
							goto l263
						l265:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('µ') {
								goto l266
							}
							position++
							if buffer[position] != rune('s') {
								goto l266
							}
							position++
							goto l263
						l266:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('m') {
								goto l267
							}
							position++
							if buffer[position] != rune('s') {
								goto l267
							}
							position++
							goto l263
						l267:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('s') {
								goto l268
							}
							position++
							goto l263
						l268:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('m') {
								goto l269
							}
							position++
							goto l263
						l269:
							position, tokenIndex = position263, tokenIndex263
							if buffer[position] != rune('h') {
								goto l251
							}
							position++
						}
					l263:
						add(rulePegText, position262)
					}
					if !_rules[ruleAction77]() {
						goto l251
					}
				}
			l253:
				add(ruleDuration, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 45 Timestamp <- <(<RFC3339Nano> Action78)> */
		func() bool {
			position270, tokenIndex270 := position, tokenIndex
			{
				position271 := position
				{
					position272 := position
					if !_rules[ruleRFC3339Nano]() {
						goto l270
					}
					add(rulePegText, position272)
				}
				if !_rules[ruleAction78]() {
					goto l270
				}
				add(ruleTimestamp, position271)
			}
			return true
		l270:
			position, tokenIndex = position270, tokenIndex270
			return false
		},
		/* 46 StringChar <- <(('\\' ('\'' / '"' / '?' / '\\' / '%' / 'a' / 'b' / 'f' / 'n' / 'r' / 't' / 'v')) / (!('"' / '\n' / '\\') .))> */
		func() bool {
			position273, tokenIndex273 := position, tokenIndex
			{
				position274 := position
				{
					position275, tokenIndex275 := position, tokenIndex
					if buffer[position] != rune('\\') {
						goto l276
					}
					position++
					{
						position277, tokenIndex277 := position, tokenIndex
						if buffer[position] != rune('\'') {
							goto l278
						}
						position++
						goto l277
					l278:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('"') {
							goto l279
						}
						position++
						goto l277
					l279:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('?') {
							goto l280
						}
						position++
						goto l277
					l280:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('\\') {
							goto l281
						}
						position++
						goto l277
					l281:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('%') {
							goto l282
						}
						position++
						goto l277
					l282:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('a') {
							goto l283
						}
						position++
						goto l277
					l283:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('b') {
							goto l284
						}
						position++
						goto l277
					l284:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('f') {
							goto l285
						}
						position++
						goto l277
					l285:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('n') {
							goto l286
						}
						position++
						goto l277
					l286:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('r') {
							goto l287
						}
						position++
						goto l277
					l287:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('t') {
							goto l288
						}
						position++
						goto l277
					l288:
						position, tokenIndex = position277, tokenIndex277
						if buffer[position] != rune('v') {
							goto l276
						}
						position++
					}
				l277:
					goto l275
				l276:
					position, tokenIndex = position275, tokenIndex275
					{
						position289, tokenIndex289 := position, tokenIndex
						{
							position290, tokenIndex290 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l291
							}
							position++
							goto l290
						l291:
							position, tokenIndex = position290, tokenIndex290
							if buffer[position] != rune('\n') {
								goto l292
							}
							position++
							goto l290
						l292:
							position, tokenIndex = position290, tokenIndex290
							if buffer[position] != rune('\\') {
								goto l289
							}
							position++
						}
					l290:
						goto l273
					l289:
						position, tokenIndex = position289, tokenIndex289
					}
					if !matchDot() {
						goto l273
					}
				}
			l275:
				add(ruleStringChar, position274)
			}
			return true
		l273:
			position, tokenIndex = position273, tokenIndex273
			return false
		},
		/* 47 Exponent <- <(('e' / 'E') ('+' / '-')? Digits)> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				{
					position295, tokenIndex295 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l296
					}
					position++
					goto l295
				l296:
					position, tokenIndex = position295, tokenIndex295
					if buffer[position] != rune('E') {
						goto l293
					}
					position++
				}
			l295:
				{
					position297, tokenIndex297 := position, tokenIndex
					{
						position299, tokenIndex299 := position, tokenIndex
						if buffer[position] != rune('+') {
							goto l300
						}
						position++
						goto l299
					l300:
						position, tokenIndex = position299, tokenIndex299
						if buffer[position] != rune('-') {
							goto l297
						}
						position++
					}
				l299:
					goto l298
				l297:
					position, tokenIndex = position297, tokenIndex297
				}
			l298:
				if !_rules[ruleDigits]() {
					goto l293
				}
				add(ruleExponent, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 48 Digits <- <([0-9] ('_'* [0-9])*)> */
		func() bool {
			position301, tokenIndex301 := position, tokenIndex
			{
				position302 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l301
				}
				position++
			l303:
				{
					position304, tokenIndex304 := position, tokenIndex
				l305:
					{
						position306, tokenIndex306 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l306
						}
						position++
						goto l305
					l306:
						position, tokenIndex = position306, tokenIndex306
					}
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l304
					}
					position++
					goto l303
				l304:
					position, tokenIndex = position304, tokenIndex304
				}
				add(ruleDigits, position302)
			}
			return true
		l301:
			position, tokenIndex = position301, tokenIndex301
			return false
		},
		/* 49 RFC3339Nano <- <(RFC3339NanoDate 'T' RFC3339NanoTime RFC3339NanoTimezone)> */
		func() bool {
			position307, tokenIndex307 := position, tokenIndex
			{
				position308 := position
				if !_rules[ruleRFC3339NanoDate]() {
					goto l307
				}
				if buffer[position] != rune('T') {
					goto l307
				}
				position++
				if !_rules[ruleRFC3339NanoTime]() {
					goto l307
				}
				if !_rules[ruleRFC3339NanoTimezone]() {
					goto l307
				}
				add(ruleRFC3339Nano, position308)
			}
			return true
		l307:
			position, tokenIndex = position307, tokenIndex307
			return false
		},
		/* 50 RFC3339NanoDate <- <(Number '-' Number '-' Number)> */
		func() bool {
			position309, tokenIndex309 := position, tokenIndex
			{
				position310 := position
				if !_rules[ruleNumber]() {
					goto l309
				}
				if buffer[position] != rune('-') {
					goto l309
				}
				position++
				if !_rules[ruleNumber]() {
					goto l309
				}
				if buffer[position] != rune('-') {
					goto l309
				}
				position++
				if !_rules[ruleNumber]() {
					goto l309
				}
				add(ruleRFC3339NanoDate, position310)
			}
			return true
		l309:
			position, tokenIndex = position309, tokenIndex309
			return false
		},
		/* 51 RFC3339NanoTime <- <(Number ':' Number ':' Number ('.' Number)?)> */
		func() bool {
			position311, tokenIndex311 := position, tokenIndex
			{
				position312 := position
				if !_rules[ruleNumber]() {
					goto l311
				}
				if buffer[position] != rune(':') {
					goto l311
				}
				position++
				if !_rules[ruleNumber]() {
					goto l311
				}
				if buffer[position] != rune(':') {
					goto l311
				}
				position++
				if !_rules[ruleNumber]() {
					goto l311
				}
				{
					position313, tokenIndex313 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l313
					}
					position++
					if !_rules[ruleNumber]() {
						goto l313
					}
					goto l314
				l313:
					position, tokenIndex = position313, tokenIndex313
				}
			l314:
				add(ruleRFC3339NanoTime, position312)
			}
			return true
		l311:
			position, tokenIndex = position311, tokenIndex311
			return false
		},
		/* 52 RFC3339NanoTimezone <- <('Z' / ('+' Number ':' Number))> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				{
					position317, tokenIndex317 := position, tokenIndex
					if buffer[position] != rune('Z') {
						goto l318
					}
					position++
					goto l317
				l318:
					position, tokenIndex = position317, tokenIndex317
					if buffer[position] != rune('+') {
						goto l315
					}
					position++
					if !_rules[ruleNumber]() {
						goto l315
					}
					if buffer[position] != rune(':') {
						goto l315
					}
					position++
					if !_rules[ruleNumber]() {
						goto l315
					}
				}
			l317:
				add(ruleRFC3339NanoTimezone, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 53 Number <- <<[0-9]+>> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				{
					position321 := position
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l319
					}
					position++
				l322:
					{
						position323, tokenIndex323 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l323
						}
						position++
						goto l322
					l323:
						position, tokenIndex = position323, tokenIndex323
					}
					add(rulePegText, position321)
				}
				add(ruleNumber, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 54 NOT <- <('!' Space)> */
		func() bool {
			position324, tokenIndex324 := position, tokenIndex
			{
				position325 := position
				if buffer[position] != rune('!') {
					goto l324
				}
				position++
				if !_rules[ruleSpace]() {
					goto l324
				}
				add(ruleNOT, position325)
			}
			return true
		l324:
			position, tokenIndex = position324, tokenIndex324
			return false
		},
		/* 55 NEG <- <('-' Space)> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				if buffer[position] != rune('-') {
					goto l326
				}
				position++
				if !_rules[ruleSpace]() {
					goto l326
				}
				add(ruleNEG, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 56 NUM_ADD <- <('+' Space)> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != rune('+') {
					goto l328
				}
				position++
				if !_rules[ruleSpace]() {
					goto l328
				}
				add(ruleNUM_ADD, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 57 NUM_SUB <- <('-' Space)> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				if buffer[position] != rune('-') {
					goto l330
				}
				position++
				if !_rules[ruleSpace]() {
					goto l330
				}
				add(ruleNUM_SUB, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 58 NUM_DIV <- <('/' Space)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if buffer[position] != rune('/') {
					goto l332
				}
				position++
				if !_rules[ruleSpace]() {
					goto l332
				}
				add(ruleNUM_DIV, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 59 NUM_MUL <- <('*' Space)> */
		func() bool {
			position334, tokenIndex334 := position, tokenIndex
			{
				position335 := position
				if buffer[position] != rune('*') {
					goto l334
				}
				position++
				if !_rules[ruleSpace]() {
					goto l334
				}
				add(ruleNUM_MUL, position335)
			}
			return true
		l334:
			position, tokenIndex = position334, tokenIndex334
			return false
		},
		/* 60 LOG_AND <- <('&' '&' Space)> */
		func() bool {
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
				if buffer[position] != rune('&') {
					goto l336
				}
				position++
				if buffer[position] != rune('&') {
					goto l336
				}
				position++
				if !_rules[ruleSpace]() {
					goto l336
				}
				add(ruleLOG_AND, position337)
			}
			return true
		l336:
			position, tokenIndex = position336, tokenIndex336
			return false
		},
		/* 61 LOG_OR <- <('|' '|' Space)> */
		func() bool {
			position338, tokenIndex338 := position, tokenIndex
			{
				position339 := position
				if buffer[position] != rune('|') {
					goto l338
				}
				position++
				if buffer[position] != rune('|') {
					goto l338
				}
				position++
				if !_rules[ruleSpace]() {
					goto l338
				}
				add(ruleLOG_OR, position339)
			}
			return true
		l338:
			position, tokenIndex = position338, tokenIndex338
			return false
		},
		/* 62 CMP_EQ <- <('=' '=' Space)> */
		func() bool {
			position340, tokenIndex340 := position, tokenIndex
			{
				position341 := position
				if buffer[position] != rune('=') {
					goto l340
				}
				position++
				if buffer[position] != rune('=') {
					goto l340
				}
				position++
				if !_rules[ruleSpace]() {
					goto l340
				}
				add(ruleCMP_EQ, position341)
			}
			return true
		l340:
			position, tokenIndex = position340, tokenIndex340
			return false
		},
		/* 63 CMP_NOTEQ <- <('!' '=' Space)> */
		func() bool {
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				if buffer[position] != rune('!') {
					goto l342
				}
				position++
				if buffer[position] != rune('=') {
					goto l342
				}
				position++
				if !_rules[ruleSpace]() {
					goto l342
				}
				add(ruleCMP_NOTEQ, position343)
			}
			return true
		l342:
			position, tokenIndex = position342, tokenIndex342
			return false
		},
		/* 64 CMP_GT <- <('>' Space)> */
		func() bool {
			position344, tokenIndex344 := position, tokenIndex
			{
				position345 := position
				if buffer[position] != rune('>') {
					goto l344
				}
				position++
				if !_rules[ruleSpace]() {
					goto l344
				}
				add(ruleCMP_GT, position345)
			}
			return true
		l344:
			position, tokenIndex = position344, tokenIndex344
			return false
		},
		/* 65 CMP_GTE <- <('>' '=' Space)> */
		func() bool {
			position346, tokenIndex346 := position, tokenIndex
			{
				position347 := position
				if buffer[position] != rune('>') {
					goto l346
				}
				position++
				if buffer[position] != rune('=') {
					goto l346
				}
				position++
				if !_rules[ruleSpace]() {
					goto l346
				}
				add(ruleCMP_GTE, position347)
			}
			return true
		l346:
			position, tokenIndex = position346, tokenIndex346
			return false
		},
		/* 66 CMP_LT <- <('<' Space)> */
		func() bool {
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				if buffer[position] != rune('<') {
					goto l348
				}
				position++
				if !_rules[ruleSpace]() {
					goto l348
				}
				add(ruleCMP_LT, position349)
			}
			return true
		l348:
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 67 CMP_LTE <- <('<' '=' Space)> */
		func() bool {
			position350, tokenIndex350 := position, tokenIndex
			{
				position351 := position
				if buffer[position] != rune('<') {
					goto l350
				}
				position++
				if buffer[position] != rune('=') {
					goto l350
				}
				position++
				if !_rules[ruleSpace]() {
					goto l350
				}
				add(ruleCMP_LTE, position351)
			}
			return true
		l350:
			position, tokenIndex = position350, tokenIndex350
			return false
		},
		/* 68 SET_IN <- <('i' 'n' Space)> */
		func() bool {
			position352, tokenIndex352 := position, tokenIndex
			{
				position353 := position
				if buffer[position] != rune('i') {
					goto l352
				}
				position++
				if buffer[position] != rune('n') {
					goto l352
				}
				position++
				if !_rules[ruleSpace]() {
					goto l352
				}
				add(ruleSET_IN, position353)
			}
			return true
		l352:
			position, tokenIndex = position352, tokenIndex352
			return false
		},
		/* 69 SET_NOTIN <- <('n' 'o' 't' ' ' 'i' 'n' Space)> */
		func() bool {
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				if buffer[position] != rune('n') {
					goto l354
				}
				position++
				if buffer[position] != rune('o') {
					goto l354
				}
				position++
				if buffer[position] != rune('t') {
					goto l354
				}
				position++
				if buffer[position] != rune(' ') {
					goto l354
				}
				position++
				if buffer[position] != rune('i') {
					goto l354
				}
				position++
				if buffer[position] != rune('n') {
					goto l354
				}
				position++
				if !_rules[ruleSpace]() {
					goto l354
				}
				add(ruleSET_NOTIN, position355)
			}
			return true
		l354:
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 70 PIPE <- <('|' Space)> */
		func() bool {
			position356, tokenIndex356 := position, tokenIndex
			{
				position357 := position
				if buffer[position] != rune('|') {
					goto l356
				}
				position++
				if !_rules[ruleSpace]() {
					goto l356
				}
				add(rulePIPE, position357)
			}
			return true
		l356:
			position, tokenIndex = position356, tokenIndex356
			return false
		},
		/* 71 DOT <- <('.' Space)> */
		func() bool {
			position358, tokenIndex358 := position, tokenIndex
			{
				position359 := position
				if buffer[position] != rune('.') {
					goto l358
				}
				position++
				if !_rules[ruleSpace]() {
					goto l358
				}
				add(ruleDOT, position359)
			}
			return true
		l358:
			position, tokenIndex = position358, tokenIndex358
			return false
		},
		/* 72 L_PARENS <- <('(' Space)> */
		func() bool {
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				if buffer[position] != rune('(') {
					goto l360
				}
				position++
				if !_rules[ruleSpace]() {
					goto l360
				}
				add(ruleL_PARENS, position361)
			}
			return true
		l360:
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 73 R_PARENS <- <(')' Space)> */
		func() bool {
			position362, tokenIndex362 := position, tokenIndex
			{
				position363 := position
				if buffer[position] != rune(')') {
					goto l362
				}
				position++
				if !_rules[ruleSpace]() {
					goto l362
				}
				add(ruleR_PARENS, position363)
			}
			return true
		l362:
			position, tokenIndex = position362, tokenIndex362
			return false
		},
		/* 74 L_BRACKET <- <('[' Space)> */
		func() bool {
			position364, tokenIndex364 := position, tokenIndex
			{
				position365 := position
				if buffer[position] != rune('[') {
					goto l364
				}
				position++
				if !_rules[ruleSpace]() {
					goto l364
				}
				add(ruleL_BRACKET, position365)
			}
			return true
		l364:
			position, tokenIndex = position364, tokenIndex364
			return false
		},
		/* 75 R_BRACKET <- <(']' Space)> */
		func() bool {
			position366, tokenIndex366 := position, tokenIndex
			{
				position367 := position
				if buffer[position] != rune(']') {
					goto l366
				}
				position++
				if !_rules[ruleSpace]() {
					goto l366
				}
				add(ruleR_BRACKET, position367)
			}
			return true
		l366:
			position, tokenIndex = position366, tokenIndex366
			return false
		},
		/* 76 L_SQUIGGLY <- <('{' Space)> */
		func() bool {
			position368, tokenIndex368 := position, tokenIndex
			{
				position369 := position
				if buffer[position] != rune('{') {
					goto l368
				}
				position++
				if !_rules[ruleSpace]() {
					goto l368
				}
				add(ruleL_SQUIGGLY, position369)
			}
			return true
		l368:
			position, tokenIndex = position368, tokenIndex368
			return false
		},
		/* 77 R_SQUIGGLY <- <'}'> */
		func() bool {
			position370, tokenIndex370 := position, tokenIndex
			{
				position371 := position
				if buffer[position] != rune('}') {
					goto l370
				}
				position++
				add(ruleR_SQUIGGLY, position371)
			}
			return true
		l370:
			position, tokenIndex = position370, tokenIndex370
			return false
		},
		/* 78 COLON <- <(':' Space)> */
		func() bool {
			position372, tokenIndex372 := position, tokenIndex
			{
				position373 := position
				if buffer[position] != rune(':') {
					goto l372
				}
				position++
				if !_rules[ruleSpace]() {
					goto l372
				}
				add(ruleCOLON, position373)
			}
			return true
		l372:
			position, tokenIndex = position372, tokenIndex372
			return false
		},
		/* 79 COMMA <- <(',' Space)> */
		func() bool {
			position374, tokenIndex374 := position, tokenIndex
			{
				position375 := position
				if buffer[position] != rune(',') {
					goto l374
				}
				position++
				if !_rules[ruleSpace]() {
					goto l374
				}
				add(ruleCOMMA, position375)
			}
			return true
		l374:
			position, tokenIndex = position374, tokenIndex374
			return false
		},
		/* 80 Space <- <Whitespace*> */
		func() bool {
			{
				position377 := position
			l378:
				{
					position379, tokenIndex379 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l379
					}
					goto l378
				l379:
					position, tokenIndex = position379, tokenIndex379
				}
				add(ruleSpace, position377)
			}
			return true
		},
		/* 81 MustSpace <- <Whitespace+> */
		func() bool {
			position380, tokenIndex380 := position, tokenIndex
			{
				position381 := position
				if !_rules[ruleWhitespace]() {
					goto l380
				}
			l382:
				{
					position383, tokenIndex383 := position, tokenIndex
					if !_rules[ruleWhitespace]() {
						goto l383
					}
					goto l382
				l383:
					position, tokenIndex = position383, tokenIndex383
				}
				add(ruleMustSpace, position381)
			}
			return true
		l380:
			position, tokenIndex = position380, tokenIndex380
			return false
		},
		/* 82 Whitespace <- <(' ' / '\t' / EOL)> */
		func() bool {
			position384, tokenIndex384 := position, tokenIndex
			{
				position385 := position
				{
					position386, tokenIndex386 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l387
					}
					position++
					goto l386
				l387:
					position, tokenIndex = position386, tokenIndex386
					if buffer[position] != rune('\t') {
						goto l388
					}
					position++
					goto l386
				l388:
					position, tokenIndex = position386, tokenIndex386
					if !_rules[ruleEOL]() {
						goto l384
					}
				}
			l386:
				add(ruleWhitespace, position385)
			}
			return true
		l384:
			position, tokenIndex = position384, tokenIndex384
			return false
		},
		/* 83 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position389, tokenIndex389 := position, tokenIndex
			{
				position390 := position
				{
					position391, tokenIndex391 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l392
					}
					position++
					if buffer[position] != rune('\n') {
						goto l392
					}
					position++
					goto l391
				l392:
					position, tokenIndex = position391, tokenIndex391
					if buffer[position] != rune('\n') {
						goto l393
					}
					position++
					goto l391
				l393:
					position, tokenIndex = position391, tokenIndex391
					if buffer[position] != rune('\r') {
						goto l389
					}
					position++
				}
			l391:
				add(ruleEOL, position390)
			}
			return true
		l389:
			position, tokenIndex = position389, tokenIndex389
			return false
		},
		/* 84 EOF <- <!.> */
		func() bool {
			position394, tokenIndex394 := position, tokenIndex
			{
				position395 := position
				{
					position396, tokenIndex396 := position, tokenIndex
					if !matchDot() {
						goto l396
					}
					goto l394
				l396:
					position, tokenIndex = position396, tokenIndex396
				}
				add(ruleEOF, position395)
			}
			return true
		l394:
			position, tokenIndex = position394, tokenIndex394
			return false
		},
		/* 86 Action0 <- <{ p.SetQuery(p.Stmts) }> */
		func() bool {
			{
				add(ruleAction0, position)
			}
			return true
		},
		/* 87 Action1 <- <{ p.SetQuery(p.Stmts) }> */
		func() bool {
			{
				add(ruleAction1, position)
			}
			return true
		},
		/* 88 Action2 <- <{ p.SetFrom(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction2, position)
			}
			return true
		},
		/* 89 Action3 <- <{ p.SetTo(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction3, position)
			}
			return true
		},
		/* 90 Action4 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction4, position)
			}
			return true
		},
		/* 91 Action5 <- <{ p.SetContextMachine(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction5, position)
			}
			return true
		},
		/* 92 Action6 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction6, position)
			}
			return true
		},
		/* 93 Action7 <- <{ p.SetContextMachine(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction7, position)
			}
			return true
		},
		/* 94 Action8 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_EQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction8, position)
			}
			return true
		},
		/* 95 Action9 <- <{ p.SetContextSession(typesv1.BinaryOp_CMP_NOTEQ, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction9, position)
			}
			return true
		},
		/* 96 Action10 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_IN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction10, position)
			}
			return true
		},
		/* 97 Action11 <- <{ p.SetContextSession(typesv1.BinaryOp_SET_NOTIN, p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction11, position)
			}
			return true
		},
		/* 98 Action12 <- <{ p.addFilterStatement(p.FilterOp) }> */
		func() bool {
			{
				add(ruleAction12, position)
			}
			return true
		},
		/* 99 Action13 <- <{ p.addSummarizeStatement(p.SummarizeOp) }> */
		func() bool {
			{
				add(ruleAction13, position)
			}
			return true
		},
		/* 100 Action14 <- <{ p.addProjectStatement(p.ProjectOp) }> */
		func() bool {
			{
				add(ruleAction14, position)
			}
			return true
		},
		/* 101 Action15 <- <{ p.setRenderSplitByStatement(p.SplitByOp) }> */
		func() bool {
			{
				add(ruleAction15, position)
			}
			return true
		},
		/* 102 Action16 <- <{ p.setFilterOp(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction16, position)
			}
			return true
		},
		/* 103 Action17 <- <{ p.startSummarizeOp() }> */
		func() bool {
			{
				add(ruleAction17, position)
			}
			return true
		},
		/* 104 Action18 <- <{ p.startSummarizeParameterNamedFunc(text) }> */
		func() bool {
			{
				add(ruleAction18, position)
			}
			return true
		},
		/* 105 Action19 <- <{ p.endSummarizeParameterNamedFunc(p.popFunc()) }> */
		func() bool {
			{
				add(ruleAction19, position)
			}
			return true
		},
		/* 106 Action20 <- <{ p.addSummarizeParameterUnnamedFunc(p.popFunc()) }> */
		func() bool {
			{
				add(ruleAction20, position)
			}
			return true
		},
		/* 107 Action21 <- <{ p.startSummarizeByUnnamedGroupExpression(text) }> */
		func() bool {
			{
				add(ruleAction21, position)
			}
			return true
		},
		/* 108 Action22 <- <{ p.endSummarizeByUnnamedGroupExpression(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction22, position)
			}
			return true
		},
		/* 109 Action23 <- <{ p.addSummarizeByUnnamedGroupExpression(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction23, position)
			}
			return true
		},
		/* 110 Action24 <- <{ p.startProjectOp() }> */
		func() bool {
			{
				add(ruleAction24, position)
			}
			return true
		},
		/* 111 Action25 <- <{ p.startProjectOpArg(text) }> */
		func() bool {
			{
				add(ruleAction25, position)
			}
			return true
		},
		/* 112 Action26 <- <{ p.setProjectOpArgValue(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction26, position)
			}
			return true
		},
		/* 113 Action27 <- <{p.startRenderSplitOp()}> */
		func() bool {
			{
				add(ruleAction27, position)
			}
			return true
		},
		/* 114 Action28 <- <{ p.addRenderSplitByOp(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction28, position)
			}
			return true
		},
		/* 115 Action29 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_ADD, rhs)) }> */
		func() bool {
			{
				add(ruleAction29, position)
			}
			return true
		},
		/* 116 Action30 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_SUB, rhs)) }> */
		func() bool {
			{
				add(ruleAction30, position)
			}
			return true
		},
		/* 117 Action31 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_MUL, rhs)) }> */
		func() bool {
			{
				add(ruleAction31, position)
			}
			return true
		},
		/* 118 Action32 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_NUM_DIV, rhs)) }> */
		func() bool {
			{
				add(ruleAction32, position)
			}
			return true
		},
		/* 119 Action33 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_AND, rhs)) }> */
		func() bool {
			{
				add(ruleAction33, position)
			}
			return true
		},
		/* 120 Action34 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_LOG_OR, rhs)) }> */
		func() bool {
			{
				add(ruleAction34, position)
			}
			return true
		},
		/* 121 Action35 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_EQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction35, position)
			}
			return true
		},
		/* 122 Action36 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_NOTEQ, rhs)) }> */
		func() bool {
			{
				add(ruleAction36, position)
			}
			return true
		},
		/* 123 Action37 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GT, rhs)) }> */
		func() bool {
			{
				add(ruleAction37, position)
			}
			return true
		},
		/* 124 Action38 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_GTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction38, position)
			}
			return true
		},
		/* 125 Action39 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LT, rhs)) }> */
		func() bool {
			{
				add(ruleAction39, position)
			}
			return true
		},
		/* 126 Action40 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_CMP_LTE, rhs)) }> */
		func() bool {
			{
				add(ruleAction40, position)
			}
			return true
		},
		/* 127 Action41 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_IN, rhs)) }> */
		func() bool {
			{
				add(ruleAction41, position)
			}
			return true
		},
		/* 128 Action42 <- <{ rhs, lhs := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprBinary(lhs, typesv1.BinaryOp_SET_NOTIN, rhs)) }> */
		func() bool {
			{
				add(ruleAction42, position)
			}
			return true
		},
		/* 129 Action43 <- <{ index, x := p.popExpr(), p.popExpr(); p.pushExpr(typesv1.ExprIndexor(x, index)) }> */
		func() bool {
			{
				add(ruleAction43, position)
			}
			return true
		},
		nil,
		/* 131 Action44 <- <{ selector, x := text, p.popExpr(); p.pushExpr(typesv1.ExprSelector(x, selector)) }> */
		func() bool {
			{
				add(ruleAction44, position)
			}
			return true
		},
		/* 132 Action45 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction45, position)
			}
			return true
		},
		/* 133 Action46 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NOT, arg)) }> */
		func() bool {
			{
				add(ruleAction46, position)
			}
			return true
		},
		/* 134 Action47 <- <{ p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, typesv1.ExprLiteral(p.Literal))); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction47, position)
			}
			return true
		},
		/* 135 Action48 <- <{ arg := p.popExpr(); p.pushExpr(typesv1.ExprUnary(typesv1.UnaryOp_NEG, arg)) }> */
		func() bool {
			{
				add(ruleAction48, position)
			}
			return true
		},
		/* 136 Action49 <- <{ p.pushExpr(typesv1.ExprLiteral(p.Literal)); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction49, position)
			}
			return true
		},
		/* 137 Action50 <- <{ fn := p.popFunc(); p.pushExpr(typesv1.ExprFuncCall(fn.Name, fn.Args...)) }> */
		func() bool {
			{
				add(ruleAction50, position)
			}
			return true
		},
		/* 138 Action51 <- <{ p.Literal = typesv1.ValStr(p.String) }> */
		func() bool {
			{
				add(ruleAction51, position)
			}
			return true
		},
		/* 139 Action52 <- <{ p.Literal = typesv1.ValDuration(p.Duration) }> */
		func() bool {
			{
				add(ruleAction52, position)
			}
			return true
		},
		/* 140 Action53 <- <{ p.Literal = typesv1.ValTime(p.Timestamp) }> */
		func() bool {
			{
				add(ruleAction53, position)
			}
			return true
		},
		/* 141 Action54 <- <{ p.Literal = typesv1.ValF64(p.F64) }> */
		func() bool {
			{
				add(ruleAction54, position)
			}
			return true
		},
		/* 142 Action55 <- <{ p.Literal = typesv1.ValI64(p.I64) }> */
		func() bool {
			{
				add(ruleAction55, position)
			}
			return true
		},
		/* 143 Action56 <- <{ p.Literal = typesv1.ValBool(p.Bool) }> */
		func() bool {
			{
				add(ruleAction56, position)
			}
			return true
		},
		/* 144 Action57 <- <{ p.Literal = typesv1.ValArr(p.popArray()...) }> */
		func() bool {
			{
				add(ruleAction57, position)
			}
			return true
		},
		/* 145 Action58 <- <{ p.Literal = typesv1.ValObj(p.popObj()...) }> */
		func() bool {
			{
				add(ruleAction58, position)
			}
			return true
		},
		/* 146 Action59 <- <{ p.pushFunc() }> */
		func() bool {
			{
				add(ruleAction59, position)
			}
			return true
		},
		/* 147 Action60 <- <{ p.setFuncName(text) }> */
		func() bool {
			{
				add(ruleAction60, position)
			}
			return true
		},
		/* 148 Action61 <- <{ p.addFuncArg(p.popExpr()) }> */
		func() bool {
			{
				add(ruleAction61, position)
			}
			return true
		},
		/* 149 Action62 <- <{ p.pushExpr(typesv1.ExprIdentifier(text)) }> */
		func() bool {
			{
				add(ruleAction62, position)
			}
			return true
		},
		/* 150 Action63 <- <{ p.String = p.parseString(text) }> */
		func() bool {
			{
				add(ruleAction63, position)
			}
			return true
		},
		/* 151 Action64 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction64, position)
			}
			return true
		},
		/* 152 Action65 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction65, position)
			}
			return true
		},
		/* 153 Action66 <- <{ p.F64 = p.parseFloat64(text) }> */
		func() bool {
			{
				add(ruleAction66, position)
			}
			return true
		},
		/* 154 Action67 <- <{ p.I64 = 0 }> */
		func() bool {
			{
				add(ruleAction67, position)
			}
			return true
		},
		/* 155 Action68 <- <{ p.I64 = p.parseInt64(text) }> */
		func() bool {
			{
				add(ruleAction68, position)
			}
			return true
		},
		/* 156 Action69 <- <{ p.Bool = true }> */
		func() bool {
			{
				add(ruleAction69, position)
			}
			return true
		},
		/* 157 Action70 <- <{ p.Bool = false }> */
		func() bool {
			{
				add(ruleAction70, position)
			}
			return true
		},
		/* 158 Action71 <- <{ p.pushArray() }> */
		func() bool {
			{
				add(ruleAction71, position)
			}
			return true
		},
		/* 159 Action72 <- <{ p.addArrItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction72, position)
			}
			return true
		},
		/* 160 Action73 <- <{ p.pushObj() }> */
		func() bool {
			{
				add(ruleAction73, position)
			}
			return true
		},
		/* 161 Action74 <- <{ p.closeObjItem(p.Literal); p.Literal = nil }> */
		func() bool {
			{
				add(ruleAction74, position)
			}
			return true
		},
		/* 162 Action75 <- <{ p.startObjItem(p.String) }> */
		func() bool {
			{
				add(ruleAction75, position)
			}
			return true
		},
		/* 163 Action76 <- <{ p.Duration = p.parseDurationF64(p.F64, text) }> */
		func() bool {
			{
				add(ruleAction76, position)
			}
			return true
		},
		/* 164 Action77 <- <{ p.Duration = p.parseDurationI64(p.I64, text) }> */
		func() bool {
			{
				add(ruleAction77, position)
			}
			return true
		},
		/* 165 Action78 <- <{ p.Timestamp = p.parseTime(time.RFC3339Nano, text) }> */
		func() bool {
			{
				add(ruleAction78, position)
			}
			return true
		},
	}
	p.rules = _rules
	return nil
}
