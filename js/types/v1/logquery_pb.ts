// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file types/v1/logquery.proto (package types.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { Val } from "./types_pb";

/**
 * @generated from message types.v1.LogQuery
 */
export class LogQuery extends Message<LogQuery> {
  /**
   * @generated from field: types.v1.Timerange timerange = 1;
   */
  timerange?: Timerange;

  /**
   * @generated from field: types.v1.Context context = 2;
   */
  context?: Context;

  /**
   * @generated from field: types.v1.Statements query = 3;
   */
  query?: Statements;

  constructor(data?: PartialMessage<LogQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.LogQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timerange", kind: "message", T: Timerange },
    { no: 2, name: "context", kind: "message", T: Context },
    { no: 3, name: "query", kind: "message", T: Statements },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogQuery {
    return new LogQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogQuery {
    return new LogQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogQuery {
    return new LogQuery().fromJsonString(jsonString, options);
  }

  static equals(a: LogQuery | PlainMessage<LogQuery> | undefined, b: LogQuery | PlainMessage<LogQuery> | undefined): boolean {
    return proto3.util.equals(LogQuery, a, b);
  }
}

/**
 * @generated from message types.v1.Timerange
 */
export class Timerange extends Message<Timerange> {
  /**
   * @generated from field: types.v1.Expr from = 1;
   */
  from?: Expr;

  /**
   * @generated from field: optional types.v1.Expr to = 2;
   */
  to?: Expr;

  constructor(data?: PartialMessage<Timerange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Timerange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "message", T: Expr },
    { no: 2, name: "to", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timerange {
    return new Timerange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timerange {
    return new Timerange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timerange {
    return new Timerange().fromJsonString(jsonString, options);
  }

  static equals(a: Timerange | PlainMessage<Timerange> | undefined, b: Timerange | PlainMessage<Timerange> | undefined): boolean {
    return proto3.util.equals(Timerange, a, b);
  }
}

/**
 * @generated from message types.v1.Context
 */
export class Context extends Message<Context> {
  /**
   * @generated from field: optional types.v1.Expr machine_id = 101;
   */
  machineId?: Expr;

  /**
   * @generated from field: optional types.v1.Expr session_id = 102;
   */
  sessionId?: Expr;

  constructor(data?: PartialMessage<Context>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Context";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 101, name: "machine_id", kind: "message", T: Expr, opt: true },
    { no: 102, name: "session_id", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Context {
    return new Context().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Context {
    return new Context().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Context {
    return new Context().fromJsonString(jsonString, options);
  }

  static equals(a: Context | PlainMessage<Context> | undefined, b: Context | PlainMessage<Context> | undefined): boolean {
    return proto3.util.equals(Context, a, b);
  }
}

/**
 * @generated from message types.v1.Statements
 */
export class Statements extends Message<Statements> {
  /**
   * statements are `|` separated
   *
   * @generated from field: repeated types.v1.Statement statements = 1;
   */
  statements: Statement[] = [];

  /**
   * @generated from field: types.v1.RenderStatement render = 2;
   */
  render?: RenderStatement;

  constructor(data?: PartialMessage<Statements>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Statements";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statements", kind: "message", T: Statement, repeated: true },
    { no: 2, name: "render", kind: "message", T: RenderStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statements {
    return new Statements().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statements {
    return new Statements().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statements {
    return new Statements().fromJsonString(jsonString, options);
  }

  static equals(a: Statements | PlainMessage<Statements> | undefined, b: Statements | PlainMessage<Statements> | undefined): boolean {
    return proto3.util.equals(Statements, a, b);
  }
}

/**
 * @generated from message types.v1.Statement
 */
export class Statement extends Message<Statement> {
  /**
   * @generated from oneof types.v1.Statement.stmt
   */
  stmt: {
    /**
     * @generated from field: types.v1.FilterOperator filter = 1;
     */
    value: FilterOperator;
    case: "filter";
  } | {
    /**
     * @generated from field: types.v1.SummarizeOperator summarize = 2;
     */
    value: SummarizeOperator;
    case: "summarize";
  } | {
    /**
     * @generated from field: types.v1.ProjectOperator project = 300;
     */
    value: ProjectOperator;
    case: "project";
  } | {
    /**
     * @generated from field: types.v1.ProjectAwayOperator project_away = 301;
     */
    value: ProjectAwayOperator;
    case: "projectAway";
  } | {
    /**
     * @generated from field: types.v1.ProjectKeepOperator project_keep = 302;
     */
    value: ProjectKeepOperator;
    case: "projectKeep";
  } | {
    /**
     * @generated from field: types.v1.ExtendOperator extend = 4;
     */
    value: ExtendOperator;
    case: "extend";
  } | {
    /**
     * @generated from field: types.v1.CountOperator count = 5;
     */
    value: CountOperator;
    case: "count";
  } | {
    /**
     * @generated from field: types.v1.DistinctOperator distinct = 6;
     */
    value: DistinctOperator;
    case: "distinct";
  } | {
    /**
     * @generated from field: types.v1.SampleOperator sample = 7;
     */
    value: SampleOperator;
    case: "sample";
  } | {
    /**
     * @generated from field: types.v1.SearchOperator search = 8;
     */
    value: SearchOperator;
    case: "search";
  } | {
    /**
     * @generated from field: types.v1.SortOperator sort = 9;
     */
    value: SortOperator;
    case: "sort";
  } | {
    /**
     * @generated from field: types.v1.TakeOperator take = 10;
     */
    value: TakeOperator;
    case: "take";
  } | {
    /**
     * @generated from field: types.v1.TopOperator top = 11;
     */
    value: TopOperator;
    case: "top";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Statement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Statement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: FilterOperator, oneof: "stmt" },
    { no: 2, name: "summarize", kind: "message", T: SummarizeOperator, oneof: "stmt" },
    { no: 300, name: "project", kind: "message", T: ProjectOperator, oneof: "stmt" },
    { no: 301, name: "project_away", kind: "message", T: ProjectAwayOperator, oneof: "stmt" },
    { no: 302, name: "project_keep", kind: "message", T: ProjectKeepOperator, oneof: "stmt" },
    { no: 4, name: "extend", kind: "message", T: ExtendOperator, oneof: "stmt" },
    { no: 5, name: "count", kind: "message", T: CountOperator, oneof: "stmt" },
    { no: 6, name: "distinct", kind: "message", T: DistinctOperator, oneof: "stmt" },
    { no: 7, name: "sample", kind: "message", T: SampleOperator, oneof: "stmt" },
    { no: 8, name: "search", kind: "message", T: SearchOperator, oneof: "stmt" },
    { no: 9, name: "sort", kind: "message", T: SortOperator, oneof: "stmt" },
    { no: 10, name: "take", kind: "message", T: TakeOperator, oneof: "stmt" },
    { no: 11, name: "top", kind: "message", T: TopOperator, oneof: "stmt" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statement {
    return new Statement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJsonString(jsonString, options);
  }

  static equals(a: Statement | PlainMessage<Statement> | undefined, b: Statement | PlainMessage<Statement> | undefined): boolean {
    return proto3.util.equals(Statement, a, b);
  }
}

/**
 * @generated from message types.v1.FilterOperator
 */
export class FilterOperator extends Message<FilterOperator> {
  /**
   * @generated from field: types.v1.Expr expr = 1;
   */
  expr?: Expr;

  constructor(data?: PartialMessage<FilterOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.FilterOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterOperator {
    return new FilterOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterOperator {
    return new FilterOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterOperator {
    return new FilterOperator().fromJsonString(jsonString, options);
  }

  static equals(a: FilterOperator | PlainMessage<FilterOperator> | undefined, b: FilterOperator | PlainMessage<FilterOperator> | undefined): boolean {
    return proto3.util.equals(FilterOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator
 */
export class SummarizeOperator extends Message<SummarizeOperator> {
  /**
   * @generated from field: types.v1.SummarizeOperator.Parameters parameters = 1;
   */
  parameters?: SummarizeOperator_Parameters;

  /**
   * @generated from field: optional types.v1.SummarizeOperator.ByGroupExpressions by_group_expressions = 2;
   */
  byGroupExpressions?: SummarizeOperator_ByGroupExpressions;

  constructor(data?: PartialMessage<SummarizeOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "message", T: SummarizeOperator_Parameters },
    { no: 2, name: "by_group_expressions", kind: "message", T: SummarizeOperator_ByGroupExpressions, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator | PlainMessage<SummarizeOperator> | undefined, b: SummarizeOperator | PlainMessage<SummarizeOperator> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator.Parameters
 */
export class SummarizeOperator_Parameters extends Message<SummarizeOperator_Parameters> {
  /**
   * @generated from field: repeated types.v1.SummarizeOperator.Parameter parameters = 1;
   */
  parameters: SummarizeOperator_Parameter[] = [];

  constructor(data?: PartialMessage<SummarizeOperator_Parameters>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator.Parameters";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parameters", kind: "message", T: SummarizeOperator_Parameter, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator_Parameters {
    return new SummarizeOperator_Parameters().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator_Parameters {
    return new SummarizeOperator_Parameters().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator_Parameters {
    return new SummarizeOperator_Parameters().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator_Parameters | PlainMessage<SummarizeOperator_Parameters> | undefined, b: SummarizeOperator_Parameters | PlainMessage<SummarizeOperator_Parameters> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator_Parameters, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator.Parameter
 */
export class SummarizeOperator_Parameter extends Message<SummarizeOperator_Parameter> {
  /**
   * @generated from field: optional types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: types.v1.FuncCall aggregate_function = 2;
   */
  aggregateFunction?: FuncCall;

  constructor(data?: PartialMessage<SummarizeOperator_Parameter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator.Parameter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier, opt: true },
    { no: 2, name: "aggregate_function", kind: "message", T: FuncCall },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator_Parameter {
    return new SummarizeOperator_Parameter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator_Parameter {
    return new SummarizeOperator_Parameter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator_Parameter {
    return new SummarizeOperator_Parameter().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator_Parameter | PlainMessage<SummarizeOperator_Parameter> | undefined, b: SummarizeOperator_Parameter | PlainMessage<SummarizeOperator_Parameter> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator_Parameter, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator.ByGroupExpressions
 */
export class SummarizeOperator_ByGroupExpressions extends Message<SummarizeOperator_ByGroupExpressions> {
  /**
   * @generated from field: repeated types.v1.SummarizeOperator.ByGroupExpression groups = 2;
   */
  groups: SummarizeOperator_ByGroupExpression[] = [];

  constructor(data?: PartialMessage<SummarizeOperator_ByGroupExpressions>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator.ByGroupExpressions";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "groups", kind: "message", T: SummarizeOperator_ByGroupExpression, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator_ByGroupExpressions {
    return new SummarizeOperator_ByGroupExpressions().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator_ByGroupExpressions {
    return new SummarizeOperator_ByGroupExpressions().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator_ByGroupExpressions {
    return new SummarizeOperator_ByGroupExpressions().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator_ByGroupExpressions | PlainMessage<SummarizeOperator_ByGroupExpressions> | undefined, b: SummarizeOperator_ByGroupExpressions | PlainMessage<SummarizeOperator_ByGroupExpressions> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator_ByGroupExpressions, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator.ByGroupExpression
 */
export class SummarizeOperator_ByGroupExpression extends Message<SummarizeOperator_ByGroupExpression> {
  /**
   * @generated from field: optional types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: types.v1.Expr scalar = 2;
   */
  scalar?: Expr;

  constructor(data?: PartialMessage<SummarizeOperator_ByGroupExpression>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator.ByGroupExpression";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier, opt: true },
    { no: 2, name: "scalar", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator_ByGroupExpression {
    return new SummarizeOperator_ByGroupExpression().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator_ByGroupExpression {
    return new SummarizeOperator_ByGroupExpression().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator_ByGroupExpression {
    return new SummarizeOperator_ByGroupExpression().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator_ByGroupExpression | PlainMessage<SummarizeOperator_ByGroupExpression> | undefined, b: SummarizeOperator_ByGroupExpression | PlainMessage<SummarizeOperator_ByGroupExpression> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator_ByGroupExpression, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectOperator
 */
export class ProjectOperator extends Message<ProjectOperator> {
  /**
   * @generated from field: repeated types.v1.ProjectOperator.Projection projections = 1;
   */
  projections: ProjectOperator_Projection[] = [];

  constructor(data?: PartialMessage<ProjectOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "projections", kind: "message", T: ProjectOperator_Projection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectOperator {
    return new ProjectOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectOperator {
    return new ProjectOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectOperator {
    return new ProjectOperator().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectOperator | PlainMessage<ProjectOperator> | undefined, b: ProjectOperator | PlainMessage<ProjectOperator> | undefined): boolean {
    return proto3.util.equals(ProjectOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectOperator.Projection
 */
export class ProjectOperator_Projection extends Message<ProjectOperator_Projection> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: optional types.v1.Expr value = 2;
   */
  value?: Expr;

  constructor(data?: PartialMessage<ProjectOperator_Projection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectOperator.Projection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
    { no: 2, name: "value", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectOperator_Projection | PlainMessage<ProjectOperator_Projection> | undefined, b: ProjectOperator_Projection | PlainMessage<ProjectOperator_Projection> | undefined): boolean {
    return proto3.util.equals(ProjectOperator_Projection, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectAwayOperator
 */
export class ProjectAwayOperator extends Message<ProjectAwayOperator> {
  /**
   * @generated from field: repeated types.v1.ProjectAwayOperator.Projection projections = 1;
   */
  projections: ProjectAwayOperator_Projection[] = [];

  constructor(data?: PartialMessage<ProjectAwayOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectAwayOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "projections", kind: "message", T: ProjectAwayOperator_Projection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectAwayOperator {
    return new ProjectAwayOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectAwayOperator {
    return new ProjectAwayOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectAwayOperator {
    return new ProjectAwayOperator().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectAwayOperator | PlainMessage<ProjectAwayOperator> | undefined, b: ProjectAwayOperator | PlainMessage<ProjectAwayOperator> | undefined): boolean {
    return proto3.util.equals(ProjectAwayOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectAwayOperator.Projection
 */
export class ProjectAwayOperator_Projection extends Message<ProjectAwayOperator_Projection> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  constructor(data?: PartialMessage<ProjectAwayOperator_Projection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectAwayOperator.Projection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectAwayOperator_Projection {
    return new ProjectAwayOperator_Projection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectAwayOperator_Projection {
    return new ProjectAwayOperator_Projection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectAwayOperator_Projection {
    return new ProjectAwayOperator_Projection().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectAwayOperator_Projection | PlainMessage<ProjectAwayOperator_Projection> | undefined, b: ProjectAwayOperator_Projection | PlainMessage<ProjectAwayOperator_Projection> | undefined): boolean {
    return proto3.util.equals(ProjectAwayOperator_Projection, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectKeepOperator
 */
export class ProjectKeepOperator extends Message<ProjectKeepOperator> {
  /**
   * @generated from field: repeated types.v1.ProjectKeepOperator.Projection projections = 1;
   */
  projections: ProjectKeepOperator_Projection[] = [];

  constructor(data?: PartialMessage<ProjectKeepOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectKeepOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "projections", kind: "message", T: ProjectKeepOperator_Projection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectKeepOperator {
    return new ProjectKeepOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectKeepOperator {
    return new ProjectKeepOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectKeepOperator {
    return new ProjectKeepOperator().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectKeepOperator | PlainMessage<ProjectKeepOperator> | undefined, b: ProjectKeepOperator | PlainMessage<ProjectKeepOperator> | undefined): boolean {
    return proto3.util.equals(ProjectKeepOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectKeepOperator.Projection
 */
export class ProjectKeepOperator_Projection extends Message<ProjectKeepOperator_Projection> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  constructor(data?: PartialMessage<ProjectKeepOperator_Projection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectKeepOperator.Projection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectKeepOperator_Projection {
    return new ProjectKeepOperator_Projection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectKeepOperator_Projection {
    return new ProjectKeepOperator_Projection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectKeepOperator_Projection {
    return new ProjectKeepOperator_Projection().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectKeepOperator_Projection | PlainMessage<ProjectKeepOperator_Projection> | undefined, b: ProjectKeepOperator_Projection | PlainMessage<ProjectKeepOperator_Projection> | undefined): boolean {
    return proto3.util.equals(ProjectKeepOperator_Projection, a, b);
  }
}

/**
 * @generated from message types.v1.ExtendOperator
 */
export class ExtendOperator extends Message<ExtendOperator> {
  /**
   * @generated from field: repeated types.v1.ExtendOperator.Projection projections = 1;
   */
  projections: ExtendOperator_Projection[] = [];

  constructor(data?: PartialMessage<ExtendOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ExtendOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "projections", kind: "message", T: ExtendOperator_Projection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendOperator {
    return new ExtendOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendOperator {
    return new ExtendOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendOperator {
    return new ExtendOperator().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendOperator | PlainMessage<ExtendOperator> | undefined, b: ExtendOperator | PlainMessage<ExtendOperator> | undefined): boolean {
    return proto3.util.equals(ExtendOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ExtendOperator.Projection
 */
export class ExtendOperator_Projection extends Message<ExtendOperator_Projection> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: types.v1.Expr value = 2;
   */
  value?: Expr;

  constructor(data?: PartialMessage<ExtendOperator_Projection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ExtendOperator.Projection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
    { no: 2, name: "value", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtendOperator_Projection {
    return new ExtendOperator_Projection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtendOperator_Projection {
    return new ExtendOperator_Projection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtendOperator_Projection {
    return new ExtendOperator_Projection().fromJsonString(jsonString, options);
  }

  static equals(a: ExtendOperator_Projection | PlainMessage<ExtendOperator_Projection> | undefined, b: ExtendOperator_Projection | PlainMessage<ExtendOperator_Projection> | undefined): boolean {
    return proto3.util.equals(ExtendOperator_Projection, a, b);
  }
}

/**
 * @generated from message types.v1.CountOperator
 */
export class CountOperator extends Message<CountOperator> {
  constructor(data?: PartialMessage<CountOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.CountOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CountOperator {
    return new CountOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CountOperator {
    return new CountOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CountOperator {
    return new CountOperator().fromJsonString(jsonString, options);
  }

  static equals(a: CountOperator | PlainMessage<CountOperator> | undefined, b: CountOperator | PlainMessage<CountOperator> | undefined): boolean {
    return proto3.util.equals(CountOperator, a, b);
  }
}

/**
 * @generated from message types.v1.DistinctOperator
 */
export class DistinctOperator extends Message<DistinctOperator> {
  constructor(data?: PartialMessage<DistinctOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.DistinctOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DistinctOperator {
    return new DistinctOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DistinctOperator {
    return new DistinctOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DistinctOperator {
    return new DistinctOperator().fromJsonString(jsonString, options);
  }

  static equals(a: DistinctOperator | PlainMessage<DistinctOperator> | undefined, b: DistinctOperator | PlainMessage<DistinctOperator> | undefined): boolean {
    return proto3.util.equals(DistinctOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SampleOperator
 */
export class SampleOperator extends Message<SampleOperator> {
  /**
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<SampleOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SampleOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleOperator {
    return new SampleOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleOperator {
    return new SampleOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleOperator {
    return new SampleOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SampleOperator | PlainMessage<SampleOperator> | undefined, b: SampleOperator | PlainMessage<SampleOperator> | undefined): boolean {
    return proto3.util.equals(SampleOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SearchOperator
 */
export class SearchOperator extends Message<SearchOperator> {
  /**
   * @generated from oneof types.v1.SearchOperator.predicate
   */
  predicate: {
    /**
     * @generated from field: string literal = 101;
     */
    value: string;
    case: "literal";
  } | {
    /**
     * @generated from field: types.v1.SearchOperator.FieldSearch field = 102;
     */
    value: SearchOperator_FieldSearch;
    case: "field";
  } | {
    /**
     * @generated from field: types.v1.SearchOperator.ExactSearch exact = 103;
     */
    value: SearchOperator_ExactSearch;
    case: "exact";
  } | {
    /**
     * @generated from field: types.v1.SearchOperator.RegexSearch regex = 104;
     */
    value: SearchOperator_RegexSearch;
    case: "regex";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * @generated from field: optional types.v1.SearchOperator.Kind kind = 2;
   */
  kind?: SearchOperator_Kind;

  constructor(data?: PartialMessage<SearchOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SearchOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 101, name: "literal", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "predicate" },
    { no: 102, name: "field", kind: "message", T: SearchOperator_FieldSearch, oneof: "predicate" },
    { no: 103, name: "exact", kind: "message", T: SearchOperator_ExactSearch, oneof: "predicate" },
    { no: 104, name: "regex", kind: "message", T: SearchOperator_RegexSearch, oneof: "predicate" },
    { no: 2, name: "kind", kind: "enum", T: proto3.getEnumType(SearchOperator_Kind), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOperator {
    return new SearchOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOperator {
    return new SearchOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOperator {
    return new SearchOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOperator | PlainMessage<SearchOperator> | undefined, b: SearchOperator | PlainMessage<SearchOperator> | undefined): boolean {
    return proto3.util.equals(SearchOperator, a, b);
  }
}

/**
 * @generated from enum types.v1.SearchOperator.Kind
 */
export enum SearchOperator_Kind {
  /**
   * @generated from enum value: Default = 0;
   */
  Default = 0,

  /**
   * @generated from enum value: CaseInsensitive = 1;
   */
  CaseInsensitive = 1,

  /**
   * @generated from enum value: CaseSensitive = 2;
   */
  CaseSensitive = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(SearchOperator_Kind)
proto3.util.setEnumType(SearchOperator_Kind, "types.v1.SearchOperator.Kind", [
  { no: 0, name: "Default" },
  { no: 1, name: "CaseInsensitive" },
  { no: 2, name: "CaseSensitive" },
]);

/**
 * @generated from message types.v1.SearchOperator.Literal
 */
export class SearchOperator_Literal extends Message<SearchOperator_Literal> {
  /**
   * @generated from field: string literal = 1;
   */
  literal = "";

  constructor(data?: PartialMessage<SearchOperator_Literal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SearchOperator.Literal";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "literal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOperator_Literal {
    return new SearchOperator_Literal().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOperator_Literal {
    return new SearchOperator_Literal().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOperator_Literal {
    return new SearchOperator_Literal().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOperator_Literal | PlainMessage<SearchOperator_Literal> | undefined, b: SearchOperator_Literal | PlainMessage<SearchOperator_Literal> | undefined): boolean {
    return proto3.util.equals(SearchOperator_Literal, a, b);
  }
}

/**
 * @generated from message types.v1.SearchOperator.FieldSearch
 */
export class SearchOperator_FieldSearch extends Message<SearchOperator_FieldSearch> {
  /**
   * @generated from field: string column = 1;
   */
  column = "";

  /**
   * @generated from field: string literal = 2;
   */
  literal = "";

  constructor(data?: PartialMessage<SearchOperator_FieldSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SearchOperator.FieldSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "literal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOperator_FieldSearch {
    return new SearchOperator_FieldSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOperator_FieldSearch {
    return new SearchOperator_FieldSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOperator_FieldSearch {
    return new SearchOperator_FieldSearch().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOperator_FieldSearch | PlainMessage<SearchOperator_FieldSearch> | undefined, b: SearchOperator_FieldSearch | PlainMessage<SearchOperator_FieldSearch> | undefined): boolean {
    return proto3.util.equals(SearchOperator_FieldSearch, a, b);
  }
}

/**
 * @generated from message types.v1.SearchOperator.ExactSearch
 */
export class SearchOperator_ExactSearch extends Message<SearchOperator_ExactSearch> {
  /**
   * @generated from field: string column = 1;
   */
  column = "";

  /**
   * @generated from field: string literal = 2;
   */
  literal = "";

  constructor(data?: PartialMessage<SearchOperator_ExactSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SearchOperator.ExactSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "literal", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOperator_ExactSearch {
    return new SearchOperator_ExactSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOperator_ExactSearch {
    return new SearchOperator_ExactSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOperator_ExactSearch {
    return new SearchOperator_ExactSearch().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOperator_ExactSearch | PlainMessage<SearchOperator_ExactSearch> | undefined, b: SearchOperator_ExactSearch | PlainMessage<SearchOperator_ExactSearch> | undefined): boolean {
    return proto3.util.equals(SearchOperator_ExactSearch, a, b);
  }
}

/**
 * @generated from message types.v1.SearchOperator.RegexSearch
 */
export class SearchOperator_RegexSearch extends Message<SearchOperator_RegexSearch> {
  /**
   * @generated from field: string column = 1;
   */
  column = "";

  /**
   * @generated from field: string regex = 2;
   */
  regex = "";

  constructor(data?: PartialMessage<SearchOperator_RegexSearch>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SearchOperator.RegexSearch";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "regex", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchOperator_RegexSearch {
    return new SearchOperator_RegexSearch().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchOperator_RegexSearch {
    return new SearchOperator_RegexSearch().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchOperator_RegexSearch {
    return new SearchOperator_RegexSearch().fromJsonString(jsonString, options);
  }

  static equals(a: SearchOperator_RegexSearch | PlainMessage<SearchOperator_RegexSearch> | undefined, b: SearchOperator_RegexSearch | PlainMessage<SearchOperator_RegexSearch> | undefined): boolean {
    return proto3.util.equals(SearchOperator_RegexSearch, a, b);
  }
}

/**
 * @generated from message types.v1.SortOperator
 */
export class SortOperator extends Message<SortOperator> {
  /**
   * @generated from field: repeated types.v1.SortOperator.ByColumn by_columns = 1;
   */
  byColumns: SortOperator_ByColumn[] = [];

  constructor(data?: PartialMessage<SortOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SortOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "by_columns", kind: "message", T: SortOperator_ByColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortOperator {
    return new SortOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortOperator {
    return new SortOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortOperator {
    return new SortOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SortOperator | PlainMessage<SortOperator> | undefined, b: SortOperator | PlainMessage<SortOperator> | undefined): boolean {
    return proto3.util.equals(SortOperator, a, b);
  }
}

/**
 * @generated from enum types.v1.SortOperator.Order
 */
export enum SortOperator_Order {
  /**
   * @generated from enum value: Desc = 0;
   */
  Desc = 0,

  /**
   * @generated from enum value: Asc = 1;
   */
  Asc = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(SortOperator_Order)
proto3.util.setEnumType(SortOperator_Order, "types.v1.SortOperator.Order", [
  { no: 0, name: "Desc" },
  { no: 1, name: "Asc" },
]);

/**
 * @generated from message types.v1.SortOperator.ByColumn
 */
export class SortOperator_ByColumn extends Message<SortOperator_ByColumn> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: optional types.v1.SortOperator.Order order = 2;
   */
  order?: SortOperator_Order;

  constructor(data?: PartialMessage<SortOperator_ByColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SortOperator.ByColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
    { no: 2, name: "order", kind: "enum", T: proto3.getEnumType(SortOperator_Order), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SortOperator_ByColumn {
    return new SortOperator_ByColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SortOperator_ByColumn {
    return new SortOperator_ByColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SortOperator_ByColumn {
    return new SortOperator_ByColumn().fromJsonString(jsonString, options);
  }

  static equals(a: SortOperator_ByColumn | PlainMessage<SortOperator_ByColumn> | undefined, b: SortOperator_ByColumn | PlainMessage<SortOperator_ByColumn> | undefined): boolean {
    return proto3.util.equals(SortOperator_ByColumn, a, b);
  }
}

/**
 * @generated from message types.v1.TakeOperator
 */
export class TakeOperator extends Message<TakeOperator> {
  /**
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  constructor(data?: PartialMessage<TakeOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.TakeOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TakeOperator {
    return new TakeOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TakeOperator {
    return new TakeOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TakeOperator {
    return new TakeOperator().fromJsonString(jsonString, options);
  }

  static equals(a: TakeOperator | PlainMessage<TakeOperator> | undefined, b: TakeOperator | PlainMessage<TakeOperator> | undefined): boolean {
    return proto3.util.equals(TakeOperator, a, b);
  }
}

/**
 * @generated from message types.v1.TopOperator
 */
export class TopOperator extends Message<TopOperator> {
  /**
   * @generated from field: int64 count = 1;
   */
  count = protoInt64.zero;

  /**
   * @generated from field: optional types.v1.TopOperator.ByColumn by_column = 2;
   */
  byColumn?: TopOperator_ByColumn;

  constructor(data?: PartialMessage<TopOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.TopOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "count", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "by_column", kind: "message", T: TopOperator_ByColumn, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopOperator {
    return new TopOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopOperator {
    return new TopOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopOperator {
    return new TopOperator().fromJsonString(jsonString, options);
  }

  static equals(a: TopOperator | PlainMessage<TopOperator> | undefined, b: TopOperator | PlainMessage<TopOperator> | undefined): boolean {
    return proto3.util.equals(TopOperator, a, b);
  }
}

/**
 * @generated from enum types.v1.TopOperator.Order
 */
export enum TopOperator_Order {
  /**
   * @generated from enum value: Desc = 0;
   */
  Desc = 0,

  /**
   * @generated from enum value: Asc = 1;
   */
  Asc = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(TopOperator_Order)
proto3.util.setEnumType(TopOperator_Order, "types.v1.TopOperator.Order", [
  { no: 0, name: "Desc" },
  { no: 1, name: "Asc" },
]);

/**
 * @generated from message types.v1.TopOperator.ByColumn
 */
export class TopOperator_ByColumn extends Message<TopOperator_ByColumn> {
  /**
   * @generated from field: types.v1.Expr scalar = 1;
   */
  scalar?: Expr;

  /**
   * @generated from field: optional types.v1.TopOperator.Order order = 2;
   */
  order?: TopOperator_Order;

  constructor(data?: PartialMessage<TopOperator_ByColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.TopOperator.ByColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalar", kind: "message", T: Expr },
    { no: 2, name: "order", kind: "enum", T: proto3.getEnumType(TopOperator_Order), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopOperator_ByColumn {
    return new TopOperator_ByColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopOperator_ByColumn {
    return new TopOperator_ByColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopOperator_ByColumn {
    return new TopOperator_ByColumn().fromJsonString(jsonString, options);
  }

  static equals(a: TopOperator_ByColumn | PlainMessage<TopOperator_ByColumn> | undefined, b: TopOperator_ByColumn | PlainMessage<TopOperator_ByColumn> | undefined): boolean {
    return proto3.util.equals(TopOperator_ByColumn, a, b);
  }
}

/**
 * @generated from message types.v1.RenderStatement
 */
export class RenderStatement extends Message<RenderStatement> {
  /**
   * @generated from oneof types.v1.RenderStatement.stmt
   */
  stmt: {
    /**
     * @generated from field: types.v1.SplitOperator split = 1;
     */
    value: SplitOperator;
    case: "split";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RenderStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.RenderStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "split", kind: "message", T: SplitOperator, oneof: "stmt" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenderStatement {
    return new RenderStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenderStatement {
    return new RenderStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenderStatement {
    return new RenderStatement().fromJsonString(jsonString, options);
  }

  static equals(a: RenderStatement | PlainMessage<RenderStatement> | undefined, b: RenderStatement | PlainMessage<RenderStatement> | undefined): boolean {
    return proto3.util.equals(RenderStatement, a, b);
  }
}

/**
 * @generated from message types.v1.SplitOperator
 */
export class SplitOperator extends Message<SplitOperator> {
  /**
   * @generated from field: types.v1.SplitOperator.ByOperator by = 2;
   */
  by?: SplitOperator_ByOperator;

  constructor(data?: PartialMessage<SplitOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SplitOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "by", kind: "message", T: SplitOperator_ByOperator },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitOperator {
    return new SplitOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitOperator {
    return new SplitOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitOperator {
    return new SplitOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SplitOperator | PlainMessage<SplitOperator> | undefined, b: SplitOperator | PlainMessage<SplitOperator> | undefined): boolean {
    return proto3.util.equals(SplitOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SplitOperator.ByOperator
 */
export class SplitOperator_ByOperator extends Message<SplitOperator_ByOperator> {
  /**
   * @generated from field: repeated types.v1.Expr scalars = 1;
   */
  scalars: Expr[] = [];

  constructor(data?: PartialMessage<SplitOperator_ByOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SplitOperator.ByOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalars", kind: "message", T: Expr, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SplitOperator_ByOperator | PlainMessage<SplitOperator_ByOperator> | undefined, b: SplitOperator_ByOperator | PlainMessage<SplitOperator_ByOperator> | undefined): boolean {
    return proto3.util.equals(SplitOperator_ByOperator, a, b);
  }
}

/**
 * @generated from message types.v1.Expr
 */
export class Expr extends Message<Expr> {
  /**
   * @generated from oneof types.v1.Expr.expr
   */
  expr: {
    /**
     * @generated from field: types.v1.Val literal = 101;
     */
    value: Val;
    case: "literal";
  } | {
    /**
     * @generated from field: types.v1.UnaryOp unary = 102;
     */
    value: UnaryOp;
    case: "unary";
  } | {
    /**
     * @generated from field: types.v1.BinaryOp binary = 103;
     */
    value: BinaryOp;
    case: "binary";
  } | {
    /**
     * @generated from field: types.v1.FuncCall func_call = 104;
     */
    value: FuncCall;
    case: "funcCall";
  } | {
    /**
     * @generated from field: types.v1.Identifier identifier = 105;
     */
    value: Identifier;
    case: "identifier";
  } | {
    /**
     * kvs['hello']
     *
     * @generated from field: types.v1.Indexor indexor = 106;
     */
    value: Indexor;
    case: "indexor";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Expr>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Expr";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 101, name: "literal", kind: "message", T: Val, oneof: "expr" },
    { no: 102, name: "unary", kind: "message", T: UnaryOp, oneof: "expr" },
    { no: 103, name: "binary", kind: "message", T: BinaryOp, oneof: "expr" },
    { no: 104, name: "func_call", kind: "message", T: FuncCall, oneof: "expr" },
    { no: 105, name: "identifier", kind: "message", T: Identifier, oneof: "expr" },
    { no: 106, name: "indexor", kind: "message", T: Indexor, oneof: "expr" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expr {
    return new Expr().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expr {
    return new Expr().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expr {
    return new Expr().fromJsonString(jsonString, options);
  }

  static equals(a: Expr | PlainMessage<Expr> | undefined, b: Expr | PlainMessage<Expr> | undefined): boolean {
    return proto3.util.equals(Expr, a, b);
  }
}

/**
 * @generated from message types.v1.UnaryOp
 */
export class UnaryOp extends Message<UnaryOp> {
  /**
   * @generated from field: types.v1.UnaryOp.Operator op = 1;
   */
  op = UnaryOp_Operator.INVALID;

  /**
   * @generated from field: types.v1.Expr arg = 2;
   */
  arg?: Expr;

  constructor(data?: PartialMessage<UnaryOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.UnaryOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(UnaryOp_Operator) },
    { no: 2, name: "arg", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnaryOp {
    return new UnaryOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnaryOp {
    return new UnaryOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnaryOp {
    return new UnaryOp().fromJsonString(jsonString, options);
  }

  static equals(a: UnaryOp | PlainMessage<UnaryOp> | undefined, b: UnaryOp | PlainMessage<UnaryOp> | undefined): boolean {
    return proto3.util.equals(UnaryOp, a, b);
  }
}

/**
 * @generated from enum types.v1.UnaryOp.Operator
 */
export enum UnaryOp_Operator {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: NOT = 1;
   */
  NOT = 1,

  /**
   * @generated from enum value: NEG = 2;
   */
  NEG = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UnaryOp_Operator)
proto3.util.setEnumType(UnaryOp_Operator, "types.v1.UnaryOp.Operator", [
  { no: 0, name: "INVALID" },
  { no: 1, name: "NOT" },
  { no: 2, name: "NEG" },
]);

/**
 * @generated from message types.v1.BinaryOp
 */
export class BinaryOp extends Message<BinaryOp> {
  /**
   * @generated from field: types.v1.Expr lhs = 1;
   */
  lhs?: Expr;

  /**
   * @generated from field: types.v1.BinaryOp.Operator op = 2;
   */
  op = BinaryOp_Operator.INVALID;

  /**
   * @generated from field: types.v1.Expr rhs = 3;
   */
  rhs?: Expr;

  constructor(data?: PartialMessage<BinaryOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.BinaryOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lhs", kind: "message", T: Expr },
    { no: 2, name: "op", kind: "enum", T: proto3.getEnumType(BinaryOp_Operator) },
    { no: 3, name: "rhs", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOp {
    return new BinaryOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOp {
    return new BinaryOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOp {
    return new BinaryOp().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOp | PlainMessage<BinaryOp> | undefined, b: BinaryOp | PlainMessage<BinaryOp> | undefined): boolean {
    return proto3.util.equals(BinaryOp, a, b);
  }
}

/**
 * @generated from enum types.v1.BinaryOp.Operator
 */
export enum BinaryOp_Operator {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: LOG_AND = 101;
   */
  LOG_AND = 101,

  /**
   * @generated from enum value: LOG_OR = 102;
   */
  LOG_OR = 102,

  /**
   * @generated from enum value: NUM_ADD = 201;
   */
  NUM_ADD = 201,

  /**
   * @generated from enum value: NUM_SUB = 202;
   */
  NUM_SUB = 202,

  /**
   * @generated from enum value: NUM_DIV = 203;
   */
  NUM_DIV = 203,

  /**
   * @generated from enum value: NUM_MUL = 204;
   */
  NUM_MUL = 204,

  /**
   * @generated from enum value: CMP_EQ = 301;
   */
  CMP_EQ = 301,

  /**
   * @generated from enum value: CMP_NOTEQ = 302;
   */
  CMP_NOTEQ = 302,

  /**
   * @generated from enum value: CMP_GT = 303;
   */
  CMP_GT = 303,

  /**
   * @generated from enum value: CMP_GTE = 304;
   */
  CMP_GTE = 304,

  /**
   * @generated from enum value: CMP_LT = 305;
   */
  CMP_LT = 305,

  /**
   * @generated from enum value: CMP_LTE = 306;
   */
  CMP_LTE = 306,

  /**
   * @generated from enum value: SET_IN = 401;
   */
  SET_IN = 401,

  /**
   * @generated from enum value: SET_NOTIN = 402;
   */
  SET_NOTIN = 402,
}
// Retrieve enum metadata with: proto3.getEnumType(BinaryOp_Operator)
proto3.util.setEnumType(BinaryOp_Operator, "types.v1.BinaryOp.Operator", [
  { no: 0, name: "INVALID" },
  { no: 101, name: "LOG_AND" },
  { no: 102, name: "LOG_OR" },
  { no: 201, name: "NUM_ADD" },
  { no: 202, name: "NUM_SUB" },
  { no: 203, name: "NUM_DIV" },
  { no: 204, name: "NUM_MUL" },
  { no: 301, name: "CMP_EQ" },
  { no: 302, name: "CMP_NOTEQ" },
  { no: 303, name: "CMP_GT" },
  { no: 304, name: "CMP_GTE" },
  { no: 305, name: "CMP_LT" },
  { no: 306, name: "CMP_LTE" },
  { no: 401, name: "SET_IN" },
  { no: 402, name: "SET_NOTIN" },
]);

/**
 * @generated from message types.v1.FuncCall
 */
export class FuncCall extends Message<FuncCall> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated types.v1.Expr args = 2;
   */
  args: Expr[] = [];

  constructor(data?: PartialMessage<FuncCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.FuncCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "message", T: Expr, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FuncCall {
    return new FuncCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FuncCall {
    return new FuncCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FuncCall {
    return new FuncCall().fromJsonString(jsonString, options);
  }

  static equals(a: FuncCall | PlainMessage<FuncCall> | undefined, b: FuncCall | PlainMessage<FuncCall> | undefined): boolean {
    return proto3.util.equals(FuncCall, a, b);
  }
}

/**
 * @generated from message types.v1.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * @generated from message types.v1.Selector
 */
export class Selector extends Message<Selector> {
  /**
   * @generated from field: types.v1.Expr x = 1;
   */
  x?: Expr;

  /**
   * @generated from field: types.v1.Identifier identifier = 2;
   */
  identifier?: Identifier;

  constructor(data?: PartialMessage<Selector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Selector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "message", T: Expr },
    { no: 2, name: "identifier", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Selector {
    return new Selector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Selector {
    return new Selector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Selector {
    return new Selector().fromJsonString(jsonString, options);
  }

  static equals(a: Selector | PlainMessage<Selector> | undefined, b: Selector | PlainMessage<Selector> | undefined): boolean {
    return proto3.util.equals(Selector, a, b);
  }
}

/**
 * @generated from message types.v1.Indexor
 */
export class Indexor extends Message<Indexor> {
  /**
   * @generated from field: types.v1.Expr x = 1;
   */
  x?: Expr;

  /**
   * @generated from field: types.v1.Expr index = 2;
   */
  index?: Expr;

  constructor(data?: PartialMessage<Indexor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Indexor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "message", T: Expr },
    { no: 2, name: "index", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Indexor {
    return new Indexor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Indexor {
    return new Indexor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Indexor {
    return new Indexor().fromJsonString(jsonString, options);
  }

  static equals(a: Indexor | PlainMessage<Indexor> | undefined, b: Indexor | PlainMessage<Indexor> | undefined): boolean {
    return proto3.util.equals(Indexor, a, b);
  }
}

