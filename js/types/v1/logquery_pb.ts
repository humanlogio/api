// @generated by protoc-gen-es v1.10.0 with parameter "target=ts,import_extension=none"
// @generated from file types/v1/logquery.proto (package types.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";
import { Val } from "./types_pb";

/**
 * @generated from message types.v1.LogQuery
 */
export class LogQuery extends Message<LogQuery> {
  /**
   * @generated from field: types.v1.Timerange timerange = 1;
   */
  timerange?: Timerange;

  /**
   * @generated from field: types.v1.Context context = 2;
   */
  context?: Context;

  /**
   * @generated from field: types.v1.Statements query = 3;
   */
  query?: Statements;

  constructor(data?: PartialMessage<LogQuery>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.LogQuery";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timerange", kind: "message", T: Timerange },
    { no: 2, name: "context", kind: "message", T: Context },
    { no: 3, name: "query", kind: "message", T: Statements },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LogQuery {
    return new LogQuery().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LogQuery {
    return new LogQuery().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LogQuery {
    return new LogQuery().fromJsonString(jsonString, options);
  }

  static equals(a: LogQuery | PlainMessage<LogQuery> | undefined, b: LogQuery | PlainMessage<LogQuery> | undefined): boolean {
    return proto3.util.equals(LogQuery, a, b);
  }
}

/**
 * @generated from message types.v1.Timerange
 */
export class Timerange extends Message<Timerange> {
  /**
   * @generated from field: types.v1.Expr from = 1;
   */
  from?: Expr;

  /**
   * @generated from field: optional types.v1.Expr to = 2;
   */
  to?: Expr;

  constructor(data?: PartialMessage<Timerange>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Timerange";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "from", kind: "message", T: Expr },
    { no: 2, name: "to", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timerange {
    return new Timerange().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timerange {
    return new Timerange().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timerange {
    return new Timerange().fromJsonString(jsonString, options);
  }

  static equals(a: Timerange | PlainMessage<Timerange> | undefined, b: Timerange | PlainMessage<Timerange> | undefined): boolean {
    return proto3.util.equals(Timerange, a, b);
  }
}

/**
 * @generated from message types.v1.Context
 */
export class Context extends Message<Context> {
  /**
   * @generated from field: optional types.v1.Expr machine_id = 101;
   */
  machineId?: Expr;

  /**
   * @generated from field: optional types.v1.Expr session_id = 102;
   */
  sessionId?: Expr;

  constructor(data?: PartialMessage<Context>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Context";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 101, name: "machine_id", kind: "message", T: Expr, opt: true },
    { no: 102, name: "session_id", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Context {
    return new Context().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Context {
    return new Context().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Context {
    return new Context().fromJsonString(jsonString, options);
  }

  static equals(a: Context | PlainMessage<Context> | undefined, b: Context | PlainMessage<Context> | undefined): boolean {
    return proto3.util.equals(Context, a, b);
  }
}

/**
 * @generated from message types.v1.Statements
 */
export class Statements extends Message<Statements> {
  /**
   * statements are `|` separated
   *
   * @generated from field: repeated types.v1.Statement statements = 1;
   */
  statements: Statement[] = [];

  /**
   * @generated from field: types.v1.RenderStatement render = 2;
   */
  render?: RenderStatement;

  constructor(data?: PartialMessage<Statements>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Statements";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statements", kind: "message", T: Statement, repeated: true },
    { no: 2, name: "render", kind: "message", T: RenderStatement },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statements {
    return new Statements().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statements {
    return new Statements().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statements {
    return new Statements().fromJsonString(jsonString, options);
  }

  static equals(a: Statements | PlainMessage<Statements> | undefined, b: Statements | PlainMessage<Statements> | undefined): boolean {
    return proto3.util.equals(Statements, a, b);
  }
}

/**
 * @generated from message types.v1.Statement
 */
export class Statement extends Message<Statement> {
  /**
   * @generated from oneof types.v1.Statement.stmt
   */
  stmt: {
    /**
     * @generated from field: types.v1.FilterOperator filter = 1;
     */
    value: FilterOperator;
    case: "filter";
  } | {
    /**
     * @generated from field: types.v1.SummarizeOperator summarize = 2;
     */
    value: SummarizeOperator;
    case: "summarize";
  } | {
    /**
     * @generated from field: types.v1.ProjectOperator project = 3;
     */
    value: ProjectOperator;
    case: "project";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Statement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Statement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "filter", kind: "message", T: FilterOperator, oneof: "stmt" },
    { no: 2, name: "summarize", kind: "message", T: SummarizeOperator, oneof: "stmt" },
    { no: 3, name: "project", kind: "message", T: ProjectOperator, oneof: "stmt" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Statement {
    return new Statement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Statement {
    return new Statement().fromJsonString(jsonString, options);
  }

  static equals(a: Statement | PlainMessage<Statement> | undefined, b: Statement | PlainMessage<Statement> | undefined): boolean {
    return proto3.util.equals(Statement, a, b);
  }
}

/**
 * @generated from message types.v1.FilterOperator
 */
export class FilterOperator extends Message<FilterOperator> {
  /**
   * @generated from field: types.v1.Expr expr = 1;
   */
  expr?: Expr;

  constructor(data?: PartialMessage<FilterOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.FilterOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "expr", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FilterOperator {
    return new FilterOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FilterOperator {
    return new FilterOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FilterOperator {
    return new FilterOperator().fromJsonString(jsonString, options);
  }

  static equals(a: FilterOperator | PlainMessage<FilterOperator> | undefined, b: FilterOperator | PlainMessage<FilterOperator> | undefined): boolean {
    return proto3.util.equals(FilterOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator
 */
export class SummarizeOperator extends Message<SummarizeOperator> {
  /**
   * @generated from field: types.v1.FuncCall aggregate_function = 1;
   */
  aggregateFunction?: FuncCall;

  /**
   * @generated from field: optional types.v1.SummarizeOperator.ByOperator by = 2;
   */
  by?: SummarizeOperator_ByOperator;

  constructor(data?: PartialMessage<SummarizeOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregate_function", kind: "message", T: FuncCall },
    { no: 2, name: "by", kind: "message", T: SummarizeOperator_ByOperator, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator {
    return new SummarizeOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator | PlainMessage<SummarizeOperator> | undefined, b: SummarizeOperator | PlainMessage<SummarizeOperator> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SummarizeOperator.ByOperator
 */
export class SummarizeOperator_ByOperator extends Message<SummarizeOperator_ByOperator> {
  /**
   * @generated from field: repeated types.v1.Expr scalars = 1;
   */
  scalars: Expr[] = [];

  constructor(data?: PartialMessage<SummarizeOperator_ByOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SummarizeOperator.ByOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalars", kind: "message", T: Expr, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SummarizeOperator_ByOperator {
    return new SummarizeOperator_ByOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SummarizeOperator_ByOperator {
    return new SummarizeOperator_ByOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SummarizeOperator_ByOperator {
    return new SummarizeOperator_ByOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SummarizeOperator_ByOperator | PlainMessage<SummarizeOperator_ByOperator> | undefined, b: SummarizeOperator_ByOperator | PlainMessage<SummarizeOperator_ByOperator> | undefined): boolean {
    return proto3.util.equals(SummarizeOperator_ByOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectOperator
 */
export class ProjectOperator extends Message<ProjectOperator> {
  /**
   * @generated from field: repeated types.v1.ProjectOperator.Projection projections = 1;
   */
  projections: ProjectOperator_Projection[] = [];

  constructor(data?: PartialMessage<ProjectOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "projections", kind: "message", T: ProjectOperator_Projection, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectOperator {
    return new ProjectOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectOperator {
    return new ProjectOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectOperator {
    return new ProjectOperator().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectOperator | PlainMessage<ProjectOperator> | undefined, b: ProjectOperator | PlainMessage<ProjectOperator> | undefined): boolean {
    return proto3.util.equals(ProjectOperator, a, b);
  }
}

/**
 * @generated from message types.v1.ProjectOperator.Projection
 */
export class ProjectOperator_Projection extends Message<ProjectOperator_Projection> {
  /**
   * @generated from field: types.v1.Identifier column = 1;
   */
  column?: Identifier;

  /**
   * @generated from field: optional types.v1.Expr value = 2;
   */
  value?: Expr;

  constructor(data?: PartialMessage<ProjectOperator_Projection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.ProjectOperator.Projection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "column", kind: "message", T: Identifier },
    { no: 2, name: "value", kind: "message", T: Expr, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProjectOperator_Projection {
    return new ProjectOperator_Projection().fromJsonString(jsonString, options);
  }

  static equals(a: ProjectOperator_Projection | PlainMessage<ProjectOperator_Projection> | undefined, b: ProjectOperator_Projection | PlainMessage<ProjectOperator_Projection> | undefined): boolean {
    return proto3.util.equals(ProjectOperator_Projection, a, b);
  }
}

/**
 * @generated from message types.v1.RenderStatement
 */
export class RenderStatement extends Message<RenderStatement> {
  /**
   * @generated from oneof types.v1.RenderStatement.stmt
   */
  stmt: {
    /**
     * @generated from field: types.v1.SplitOperator split = 1;
     */
    value: SplitOperator;
    case: "split";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<RenderStatement>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.RenderStatement";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "split", kind: "message", T: SplitOperator, oneof: "stmt" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RenderStatement {
    return new RenderStatement().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RenderStatement {
    return new RenderStatement().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RenderStatement {
    return new RenderStatement().fromJsonString(jsonString, options);
  }

  static equals(a: RenderStatement | PlainMessage<RenderStatement> | undefined, b: RenderStatement | PlainMessage<RenderStatement> | undefined): boolean {
    return proto3.util.equals(RenderStatement, a, b);
  }
}

/**
 * @generated from message types.v1.SplitOperator
 */
export class SplitOperator extends Message<SplitOperator> {
  /**
   * @generated from field: types.v1.SplitOperator.ByOperator by = 2;
   */
  by?: SplitOperator_ByOperator;

  constructor(data?: PartialMessage<SplitOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SplitOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "by", kind: "message", T: SplitOperator_ByOperator },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitOperator {
    return new SplitOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitOperator {
    return new SplitOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitOperator {
    return new SplitOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SplitOperator | PlainMessage<SplitOperator> | undefined, b: SplitOperator | PlainMessage<SplitOperator> | undefined): boolean {
    return proto3.util.equals(SplitOperator, a, b);
  }
}

/**
 * @generated from message types.v1.SplitOperator.ByOperator
 */
export class SplitOperator_ByOperator extends Message<SplitOperator_ByOperator> {
  /**
   * @generated from field: repeated types.v1.Expr scalars = 1;
   */
  scalars: Expr[] = [];

  constructor(data?: PartialMessage<SplitOperator_ByOperator>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.SplitOperator.ByOperator";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "scalars", kind: "message", T: Expr, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SplitOperator_ByOperator {
    return new SplitOperator_ByOperator().fromJsonString(jsonString, options);
  }

  static equals(a: SplitOperator_ByOperator | PlainMessage<SplitOperator_ByOperator> | undefined, b: SplitOperator_ByOperator | PlainMessage<SplitOperator_ByOperator> | undefined): boolean {
    return proto3.util.equals(SplitOperator_ByOperator, a, b);
  }
}

/**
 * @generated from message types.v1.Expr
 */
export class Expr extends Message<Expr> {
  /**
   * @generated from oneof types.v1.Expr.expr
   */
  expr: {
    /**
     * @generated from field: types.v1.Val literal = 101;
     */
    value: Val;
    case: "literal";
  } | {
    /**
     * @generated from field: types.v1.UnaryOp unary = 102;
     */
    value: UnaryOp;
    case: "unary";
  } | {
    /**
     * @generated from field: types.v1.BinaryOp binary = 103;
     */
    value: BinaryOp;
    case: "binary";
  } | {
    /**
     * @generated from field: types.v1.FuncCall func_call = 104;
     */
    value: FuncCall;
    case: "funcCall";
  } | {
    /**
     * @generated from field: types.v1.Identifier identifier = 105;
     */
    value: Identifier;
    case: "identifier";
  } | {
    /**
     * msg.hello.world
     *
     * @generated from field: types.v1.Selector selector = 106;
     */
    value: Selector;
    case: "selector";
  } | {
    /**
     * kvs['hello']
     *
     * @generated from field: types.v1.Indexor indexor = 107;
     */
    value: Indexor;
    case: "indexor";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Expr>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Expr";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 101, name: "literal", kind: "message", T: Val, oneof: "expr" },
    { no: 102, name: "unary", kind: "message", T: UnaryOp, oneof: "expr" },
    { no: 103, name: "binary", kind: "message", T: BinaryOp, oneof: "expr" },
    { no: 104, name: "func_call", kind: "message", T: FuncCall, oneof: "expr" },
    { no: 105, name: "identifier", kind: "message", T: Identifier, oneof: "expr" },
    { no: 106, name: "selector", kind: "message", T: Selector, oneof: "expr" },
    { no: 107, name: "indexor", kind: "message", T: Indexor, oneof: "expr" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Expr {
    return new Expr().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Expr {
    return new Expr().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Expr {
    return new Expr().fromJsonString(jsonString, options);
  }

  static equals(a: Expr | PlainMessage<Expr> | undefined, b: Expr | PlainMessage<Expr> | undefined): boolean {
    return proto3.util.equals(Expr, a, b);
  }
}

/**
 * @generated from message types.v1.UnaryOp
 */
export class UnaryOp extends Message<UnaryOp> {
  /**
   * @generated from field: types.v1.UnaryOp.Operator op = 1;
   */
  op = UnaryOp_Operator.INVALID;

  /**
   * @generated from field: types.v1.Expr arg = 2;
   */
  arg?: Expr;

  constructor(data?: PartialMessage<UnaryOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.UnaryOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "op", kind: "enum", T: proto3.getEnumType(UnaryOp_Operator) },
    { no: 2, name: "arg", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnaryOp {
    return new UnaryOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnaryOp {
    return new UnaryOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnaryOp {
    return new UnaryOp().fromJsonString(jsonString, options);
  }

  static equals(a: UnaryOp | PlainMessage<UnaryOp> | undefined, b: UnaryOp | PlainMessage<UnaryOp> | undefined): boolean {
    return proto3.util.equals(UnaryOp, a, b);
  }
}

/**
 * @generated from enum types.v1.UnaryOp.Operator
 */
export enum UnaryOp_Operator {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: NOT = 1;
   */
  NOT = 1,

  /**
   * @generated from enum value: NEG = 2;
   */
  NEG = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(UnaryOp_Operator)
proto3.util.setEnumType(UnaryOp_Operator, "types.v1.UnaryOp.Operator", [
  { no: 0, name: "INVALID" },
  { no: 1, name: "NOT" },
  { no: 2, name: "NEG" },
]);

/**
 * @generated from message types.v1.BinaryOp
 */
export class BinaryOp extends Message<BinaryOp> {
  /**
   * @generated from field: types.v1.Expr lhs = 1;
   */
  lhs?: Expr;

  /**
   * @generated from field: types.v1.BinaryOp.Operator op = 2;
   */
  op = BinaryOp_Operator.INVALID;

  /**
   * @generated from field: types.v1.Expr rhs = 3;
   */
  rhs?: Expr;

  constructor(data?: PartialMessage<BinaryOp>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.BinaryOp";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "lhs", kind: "message", T: Expr },
    { no: 2, name: "op", kind: "enum", T: proto3.getEnumType(BinaryOp_Operator) },
    { no: 3, name: "rhs", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BinaryOp {
    return new BinaryOp().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BinaryOp {
    return new BinaryOp().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BinaryOp {
    return new BinaryOp().fromJsonString(jsonString, options);
  }

  static equals(a: BinaryOp | PlainMessage<BinaryOp> | undefined, b: BinaryOp | PlainMessage<BinaryOp> | undefined): boolean {
    return proto3.util.equals(BinaryOp, a, b);
  }
}

/**
 * @generated from enum types.v1.BinaryOp.Operator
 */
export enum BinaryOp_Operator {
  /**
   * @generated from enum value: INVALID = 0;
   */
  INVALID = 0,

  /**
   * @generated from enum value: LOG_AND = 101;
   */
  LOG_AND = 101,

  /**
   * @generated from enum value: LOG_OR = 102;
   */
  LOG_OR = 102,

  /**
   * @generated from enum value: NUM_ADD = 201;
   */
  NUM_ADD = 201,

  /**
   * @generated from enum value: NUM_SUB = 202;
   */
  NUM_SUB = 202,

  /**
   * @generated from enum value: NUM_DIV = 203;
   */
  NUM_DIV = 203,

  /**
   * @generated from enum value: NUM_MUL = 204;
   */
  NUM_MUL = 204,

  /**
   * @generated from enum value: CMP_EQ = 301;
   */
  CMP_EQ = 301,

  /**
   * @generated from enum value: CMP_NOTEQ = 302;
   */
  CMP_NOTEQ = 302,

  /**
   * @generated from enum value: CMP_GT = 303;
   */
  CMP_GT = 303,

  /**
   * @generated from enum value: CMP_GTE = 304;
   */
  CMP_GTE = 304,

  /**
   * @generated from enum value: CMP_LT = 305;
   */
  CMP_LT = 305,

  /**
   * @generated from enum value: CMP_LTE = 306;
   */
  CMP_LTE = 306,

  /**
   * @generated from enum value: SET_IN = 401;
   */
  SET_IN = 401,

  /**
   * @generated from enum value: SET_NOTIN = 402;
   */
  SET_NOTIN = 402,
}
// Retrieve enum metadata with: proto3.getEnumType(BinaryOp_Operator)
proto3.util.setEnumType(BinaryOp_Operator, "types.v1.BinaryOp.Operator", [
  { no: 0, name: "INVALID" },
  { no: 101, name: "LOG_AND" },
  { no: 102, name: "LOG_OR" },
  { no: 201, name: "NUM_ADD" },
  { no: 202, name: "NUM_SUB" },
  { no: 203, name: "NUM_DIV" },
  { no: 204, name: "NUM_MUL" },
  { no: 301, name: "CMP_EQ" },
  { no: 302, name: "CMP_NOTEQ" },
  { no: 303, name: "CMP_GT" },
  { no: 304, name: "CMP_GTE" },
  { no: 305, name: "CMP_LT" },
  { no: 306, name: "CMP_LTE" },
  { no: 401, name: "SET_IN" },
  { no: 402, name: "SET_NOTIN" },
]);

/**
 * @generated from message types.v1.FuncCall
 */
export class FuncCall extends Message<FuncCall> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: repeated types.v1.Expr args = 2;
   */
  args: Expr[] = [];

  constructor(data?: PartialMessage<FuncCall>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.FuncCall";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "args", kind: "message", T: Expr, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FuncCall {
    return new FuncCall().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FuncCall {
    return new FuncCall().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FuncCall {
    return new FuncCall().fromJsonString(jsonString, options);
  }

  static equals(a: FuncCall | PlainMessage<FuncCall> | undefined, b: FuncCall | PlainMessage<FuncCall> | undefined): boolean {
    return proto3.util.equals(FuncCall, a, b);
  }
}

/**
 * @generated from message types.v1.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * @generated from message types.v1.Selector
 */
export class Selector extends Message<Selector> {
  /**
   * @generated from field: types.v1.Expr x = 1;
   */
  x?: Expr;

  /**
   * @generated from field: types.v1.Identifier identifier = 2;
   */
  identifier?: Identifier;

  constructor(data?: PartialMessage<Selector>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Selector";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "message", T: Expr },
    { no: 2, name: "identifier", kind: "message", T: Identifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Selector {
    return new Selector().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Selector {
    return new Selector().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Selector {
    return new Selector().fromJsonString(jsonString, options);
  }

  static equals(a: Selector | PlainMessage<Selector> | undefined, b: Selector | PlainMessage<Selector> | undefined): boolean {
    return proto3.util.equals(Selector, a, b);
  }
}

/**
 * @generated from message types.v1.Indexor
 */
export class Indexor extends Message<Indexor> {
  /**
   * @generated from field: types.v1.Expr x = 1;
   */
  x?: Expr;

  /**
   * @generated from field: types.v1.Expr index = 2;
   */
  index?: Expr;

  constructor(data?: PartialMessage<Indexor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "types.v1.Indexor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "x", kind: "message", T: Expr },
    { no: 2, name: "index", kind: "message", T: Expr },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Indexor {
    return new Indexor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Indexor {
    return new Indexor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Indexor {
    return new Indexor().fromJsonString(jsonString, options);
  }

  static equals(a: Indexor | PlainMessage<Indexor> | undefined, b: Indexor | PlainMessage<Indexor> | undefined): boolean {
    return proto3.util.equals(Indexor, a, b);
  }
}

